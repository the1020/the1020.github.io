[ { "title": "📸 2023-01-25", "url": "/posts/230125TIL/", "categories": "TIL", "tags": "프런트엔드, css", "date": "2023-01-25 22:28:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 인프콘 2022 정리하는 글 작성중 [NHN FORWARD 22] 거대한 서비스 쪼개서 마이크로 프런트엔드 만들기 인터랙티브 웹 개발 제대로 시작하기 transform, transition, animation, 3d 다시 듣기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?" }, { "title": "📸 2023-01-24", "url": "/posts/230124TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트, book", "date": "2023-01-24 23:11:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 표 병합 - 자바스크립트 글 작성 마무리하기 📖 2022 제13회 젊은작가상 수상작품집 완독🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 글을 잘 쓰고 싶을수록 글이 더 길어지고 복잡해진다. 글쓰기 책을 찾아서 읽어봐야 하는건가…🤔🌟 내일은 어떻게 해보고 싶으세요? 내일은 엄청 춥다는데… 집에서 책을 읽고 싶은데 리디셀렉트를 결제할까 고민중…!📖 2022 제13회 젊은작가상 수상작품집아직 두 권밖에 읽지 못했지만 올해 읽는 책은 다 재밌다. 매해 읽었는데 갈수록 더 재밌어진다. 몇 년 읽어보니 소설도 유행을 따르는거 같다.(잘 모르지만😅) 난 요즘 유행이 마음에 든다. 내가 생각 못해봤던 세계이며 이 때까지 접하지 못했던 주제가 많기 때문이다.주제를 선정하고 글쓰는 능력까지 대단한 작가님들이 놀랍고 다음 작품이 궁금해진다. 단편소설을 안좋아했는데 작년부터 재밌는 단편을 많이 발견해서 단편소설을 발견하면 기대된다!" }, { "title": "📸 2023-01-22", "url": "/posts/230122TIL/", "categories": "TIL", "tags": "book", "date": "2023-01-22 22:59:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 📖 아버지의 해방일지 완독🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?2023년에 주목해야 할 웹개발 트렌드 2023년에 주목해야 할 웹개발 트렌드를 보고 정리! Javascript와 Typescript의 중요성 인지 많은 기술들이 나오는데 그 기술들이 왜 나왔는지 이해하는 것이 중요 rest api보다는 GraphQL 선호, Saas 플랫폼 22년 웹 프레임워크 역시 리액트가 월등히 많이 사용됨, 제이쿼리도 많이 사용함 웹 개발언어는 자바스크립트, 모든 개발언어에서는 파이썬, 타입스크립트 많이 사용 개발 툴 1위는 docker, 2위는 npm (git은 제외)📖 아버지의 해방일지 🐝 책 정보올해 첫 책이지만 아마 올해 최고의 책이 되지 않을까 싶다. 여러 매체에서 2022년 올해의 책으로 선정되길래 호기심이 생겼다. 책 소개에 빨치산, 빨갱이 등의 키워드가 눈에 띄었다. 잘 모르는 주제라 잠시 고민했지만 남이 읽는 것, 특히 베스트셀러 같은건 다 읽어보고 싶은 스타일이라 길게 고민하지 않게 읽었다.소설은 시작과 끝은 이렇다. 🔖 p.7 “아버지가 죽었다. 전봇대에 머리를 박고.” 🔖 p.265 “아버지 유골을 손에 쥔 채 나는 울었다. (중략) 그게 나의 아버지, 빨치산이 아닌, 빨갱이도 아닌, 나의 아버지.”아버지의 죽음을 맞이한 날과 장례를 치르며 변한 딸의 감정을 직설적으로 알 수 있는 문장이지 않을까 싶다. 빨치산의 자식으로 살아가며 마음의 문을 닫은 화자가 아버지의 장례식에 찾아온 지인들로 인해 “혁명가였고 빨치산의 동지였지만 그전에 자식이고 형제였으며, 남자이고 연인인”(P.249) 아버지를 이해하게 된다. 빨치산 관련된 내용은 모르기 때문에 검색하면서 읽었다. 책 뒷표지의 박혜진 아나운서의 추천사에 “나는 그 시절을 보낸 이들의 세계를 짐작이나 할 수 있을까.“라는 문장을 격하게 공감한다. 나 역시 읽으면서 계속 했던 생각이다.하지만 빨치산 보다는 아버지의 관계에 더 초점을 둔 소설이라고 느껴진다. 나도 딸이기에 내가 가장 몰입할 수 밖에 없었던 구간은 극 중 아버지가 아버지로써 화자와 함께한 순간을 회상하는 부분이었다.[알릴레오 북’s 85회] 죽음에서 시작되는 이야기 / 아버지의 해방일지 - 정지아 편에서 유시민 작가는 많은 사람들이 이 책의 아버지 이야기에 감동받을 수도 있지만 본인들의 아버지를 생각한다. 나도 아버지 생각이 많이 났다(27:55)고 언급한다. 덧붙여, 정지아 작가는 많은 독자들이 본인 아버지의 해방일지를 써보고 싶어한다고 말한다. 나도 마찬가지다. 책을 읽으며 인덱스를 붙인 곳은 아버지로써의 모습이 나타난 부분이 대부분이다. 들은게 많이 없어 잘 모르는 아버지의 일생을 머릿속으로 훑어보기도 했고 아빠와 함께 했던 나의 어린 시절도 많이 떠올렸다. 위 영상에서 정지아 작가는 내 부모는 어떻게 살아서 저런 관계를 맺고 있는 것일까라는 생각이 들었다고 한다. 예전부터 엄마아빠를 보며 들었던 생각이다. 내가 나이 들어서도 서로를 이해하고 챙겨주는 사람들을 곁에 둘 수 있을까.우리 아빠는 빨갱이도 아니고 전라도 사람도 아니지만 주제가 주제인지라 읽는 내내 아빠 생각을 정말 많이 했다. 책을 읽으며 이렇게 많이 울어본 적이 있나 싶다. 아마 얼마 지나지 않아 또 읽을 거 같다." }, { "title": "📸 2023-01-16", "url": "/posts/230116TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트, CSS", "date": "2023-01-16 18:14:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 표 병합 - 자바스크립트 인터랙티브 웹 개발 제대로 시작하기 강의 수강 animation의 속성 (@keyframes으로 애니메이션 만들기, animation의 각 속성 이용해서 적용해보기) 3D 공간감을 줄 수 있는 속성(공간감을 주기 위한 perspective, 자식 요소에게 3D 속성 영향을 주는 transform-style: preserve-3d 👈 이건 아직 잘모르겠다.) CSS 레이아웃 - 처음부터 반응형 웹까지 핵심만 간단히 정리해 봅시다. 인터랙티브 웹 개발 제대로 시작하기 강의를 듣는데 CSS 기본 문법 중 모르는게 종종 등장해서 강사님의 유투브에 있는 기본 강의를 들었는데 설명 잘해주신다.👍 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 자바스크립트 객체의 getter, setter를 쓸 때, 아래 코드처럼 getter 함수명을 프로퍼티 이름과 동일하게 사용하면 Maximum call stack size exceeded Error가 발생한다. obj.value()로 getter를 호출하면 return this.value라는 구문이 value라는 프로퍼티의 값을 반환하는게 아니라 getter 함수 자체를 반환한다. 따라서 무한반복하게 되고, 콜스택 초과 에러가 발생한다. const obj = { value: \"\", get value() { return this.value; //[Exception: RangeError: Maximum call stack size exceeded at get value [as value] (&lt;anonymous&gt;:4:17)... }, set value(value) { this.value = value; },};obj.value = \"A\"; //RangeError: Maximum call stack size exceeded 이를 해결하기 위해서 getter,setter로 특정 프로퍼티의 값을 읽거나 수정한다면 그 프로퍼티 값에 _를 붙여주는 것이 좋다. const obj = { _value: \"\", get value() { return this._value; }, set value(value) { this._value = value; },};obj.value();obj.value = \"A\"; 🐝 참고 [JS] Maximum call stack size exceeded 해결 | class getter setter 이해하기 getter setter Maximum call stack size exceeded Error - stackoverflow CSS 기본 스타일 reset 하는 코드를 사용하는 경우가 있다고 한다. 말 그대로 태그마다 기존에 적용된 속성을 초기화시킨다.(이런 식으로 쓰는거 같다. 👉 CSS Tools: Reset CSS - meyerweb.com) html,body,div,span,h1,h2,table { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit;} 🌟 내일은 어떻게 해보고 싶으세요? 인터랙티브 웹 개발 제대로 시작하기 수강하기 프로그래머스 표 병합 - 자바스크립트 글 작성 마무리하기" }, { "title": "프로그래머스 표 병합 - 자바스크립트", "url": "/posts/programmers-150366/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2023-01-15 15:06:25 +0900", "snippet": "📄 문제프로그래머스 &gt; 2023 KAKAO BLIND RECRUITMENT &gt; 표 병합구현해야 하는 것은표를 두고 명령어에 따라 셀의 값을 변경해야 한다.명령의 종류는 총 5가지로 다음과 같다. 명령어 기능 UPDATE r c value - (r, c) 위치의 셀을 선택합니다. -선택한 셀의 값을 value로 바꿉니다. UPDATE value1 value2 - value1을 값으로 가지고 있는 모든 셀을 선택합니다. - 선택한 셀의 값을 value2로 바꿉니다. MERGE r1 c1 r2 c2 - (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀을 선택하여 병합합니다. - 선택한 두 위치의 셀이 같은 셀일 경우 무시합니다. - 선택한 두 셀은 서로 인접하지 않을 수도 있습니다. 이 경우 (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀만 영향을 받으며, 그 사이에 위치한 셀들은 영향을 받지 않습니다. - 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 됩니다. - 두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1, c1) 위치의 셀 값을 가지게 됩니다. - 이후 (r1, c1) 와 (r2, c2) 중 어느 위치를 선택하여도 병합된 셀로 접근합니다. UNMERGE r c - (r, c) 위치의 셀을 선택하여 해당 셀의 모든 병합을 해제합니다. - 선택한 셀이 포함하고 있던 모든 셀은 프로그램 실행 초기의 상태로 돌아갑니다. - 병합을 해제하기 전 셀이 값을 가지고 있었을 경우 (r, c) 위치의 셀이 그 값을 가지게 됩니다. PRINT r c - (r, c) 위치의 셀을 선택하여 셀의 값을 출력합니다. - 선택한 셀이 비어있을 경우 “EMPTY”를 출력합니다. 1️⃣ 셀의 값을 저장할 배열과 참조하는 셀의 위치를 저장할 배열을 선언한다.가장 주목해야 할 명령어는 MERGE와 UNMERGE다. MERGE된 셀은 본인 값 대신 병합된 셀의 값을 갖는다.(앞으로 병합된 셀을 상위 병합이라고 하겠다.) 때문에 상위 병합을 기억하고 있어야 한다.(1)셀의 값을 저장할 배열과 (2)상위 병합을 저장할 배열을 각각 선언하고 초기화한다. 표의 크기는 50 x 50으로 고정되어 있고, 1번 인덱스부터 사용하기 위해 51 x 51인 2차원 배열을 사용한다.function solution(commands) { // 초기의 모든 셀은 비어 있다. // 그리고 PRINT 명령에서 빈 값은 \"EMPTY\"로 출력하기 때문에 \"EMPTY\"로 초기화한다. const arr = Array.from({ length: 51 }, () =&gt; Array.from({ length: 51 }, () =&gt; \"EMPTY\") ); // 초기에는 본인 셀의 값을 가리킨다. 그러므로 최초 값은 본인 위치를 저장한다. \"i, j\" 포맷으로 저장한다. const parent = Array.from({ length: 51 }, (_, i) =&gt; Array.from({ length: 51 }, (_, j) =&gt; `${i},${j}`) );}두 배열을 초기화하면 다음과 같다.2️⃣ 가장 복잡한 MERGE 명령에 대한 기능부터 구현하자.MERGE를 구현하기 위해서 주의해야 할 점은 두 가지다. 하나는 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 되는 것이고, 또 하나는 이미 다른 셀에 병합된 셀을 처리하는 것이다.MERGE r1 c1 r2 c2에서 기본적으로 (r2, c2)가 (r1, c1)으로 병합되는데 (r1, c1)이 빈 값이라면 반대로 병합을 수행하라는거다.초기 상태에서 MERGE 1 1 2 1라는 명령어가 실행해보자. 이 때, 두 셀 모두 값이 있다고 가정한다.(2, 1)가 (1, 1)으로 병합된다. 즉, (2, 1)의 상위 병합은 (1, 1)이다. 따라서 parent[2][1]은 “1,1”이라는 값을 얻게 된다. 그리고 (2, 1)에 접근했을 때 (1, 1) 값을 반환해야 한다. 이 때, 값을 찾을 때마다 (1, 1)을 찾아가서 값을 얻어와도 되지만 병합 관계가 커진다면 시간이 오래 걸릴 것이다.바로 값을 반환하기 위해 상위 병합 값을 본인 셀에 저장한다. 그럼 arr[1][1]은 arr[2][1]의 값이 된다.하나의 MERGE 명령이 실행되고, 병합당하는 셀이 (r, c)라면 parent[r][c]와 arr[r][c]이 갱신된다.여기서 MERGE 1 1 1 2를 실행하면 위와 동일하게 arr[1][2]와 parent[1][2]가 갱신된다.이번엔 초기 상태에서 MERGE 2 3 3 3라는 명령어가 실행해보자. 이번엔 두 번째 셀만 값이 있다고 가정한다.(2, 3)은 비어있기 때문에 (2, 3)이 (3, 3)으로 병합된다. 따라서 parent[2][3]은 “3,3”이라는 값을 얻고 arr[2][3]은 arr[3][3]이 가진 값으로 갱신된다.여기서 MERGE 2 2 2 3 명령을 실행해보자. (2, 2)는 비어있기 때문에 (2, 3)으로 병합된다. (2, 3)은 이미 (3, 3)에 병합되어 있다. 그러므로 (2, 2) -&gt; (2, 3) -&gt; (3, 3)으로 병합된다. 따라서 (2, 2)의 상위 병합은 (3, 3)이 된다.arr[2][2]은 어떤 값을 가져야 할까? 병합 시 본인 셀을 상위 병합의 값으로 갱신하기로 했으므로 arr[3][3]까지 찾아가서 값을 가져오지 않고 arr[2][3]의 값으로 갱신하면 된다. 참조 값 역시 parent[2][3]이 가진 값으로 갱신해주면 된다.한 번만 더 해보자. 위와 같은 병합관계일 때, MERGE 3 1 2 2 명령을 수행해보겠다. 이 때, (3, 1)은 값이 있다고 가정한다.명령대로라면 (2, 2)가 (3, 1)로 병합된다. 현재 (2, 2)는 (3, 3)에 병합되어 있다. 그러므로 (3, 3)이 (3, 1)로 병합되고, (3, 3)에 병합된 셀들도 (3, 1)로 병합되는 것이다. 즉, (2, 2) -&gt; (2, 3) -&gt; (3, 3) -&gt; (3, 1)으로 병합되었고, 결론적으로 (2, 2), (2, 3), (3, 3)의 상위 병합은 (3, 1)인 것이다.따라서 병합되는 셀이 다른 셀에 이미 병합되어 있다면 병합되는 셀의 상위 병합과 이 상위 병합에 병합된 모든 셀들의 값과 참조 셀의 위치를 변경해줘야 한다. 아래 그림을 보면 이해가 쉬울 것이다.이제 다시 처음으로 돌아가보자. MERGE r1 c1 r2 c2에서 (r1, c1)이 비어있으면 (r2, c2)으로 병합되고, 그게 아니면 (r2, c2)가 (r1, c1)으로 병합된다.무조건 (r2, c2)가 (r1, c1)에 병합되도록 한다면 조건문을 제거할 수 있고 이해하기 수월하다.그러기 위해서 MERGE가 수행되면 처음으로 (r1, c1)과 (r2, c2)이 각각 비어있는지 체크해보자. (r1, c1)이 빈 값이고 (r2, c2)가 빈 값이 아니라면 구조분해 할당을 통해 서로 값을 교환하면 원하던대로 무조건 (r2, c2)이 (r1, c1)으로 병합된다.코드로 확인해보자.function merge(r1, c1, r2, c2) { // (r1, c1)이 비었다면 (r2, c2)로 병합되어야 하므로 // r2를 r1으로, c2를 c1으로 변경하고 반대로도 적용한다.(구조 분해 할당 사용) if (arr[r1][c1] === \"EMPTY\" &amp;&amp; arr[r2][c2] !== \"EMPTY\") [r1, c1, r2, c2] = [r2, c2, r1, c1]; // 갱신되는 값은 (r1, c1)이 가진 값이다. let new_value = arr[r1][c1]; // 단순히 (r2, c2)의 참조 값만 변경하는 것이 아니다. // (r2, c2)가 참조하던 값(병합당한 셀의 위치)과 그 셀을 참조하는 모든 셀들의 참조 값을 (r1, c1)으로 갱신해야 한다. let change_pointer = parent[r2][c2]; for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { if (parent[i][j] === change_pointer) { parent[i][j] = parent[r1][c1]; arr[i][j] = new_value; } } }}3️⃣ UNMERGE 명령에 대한 기능을 구현하자.UNMERGE r c명령이 수행되면 (r, c)에 연결된 병합 관계를 모두 해제한다. 이건 (r, c)의 상위 병합과 그 상위 병합에 병합된 모든 셀을 초기 상태로 바꿔야 한다는 의미다. 초기 상태란 arr는 “EMPTY”로, parent는 본인 위치를 갖는 것이다. 그리고 (r, c)가 원래 값을 가지고 있었다면 그 값은 유지해야 한다.위 MERGE를 설명하며 만든 병합 관계에서 UNMERGE 2 3 명령을 수행해보자.(2, 3)에 연결된 병합관계는 (2, 2) -&gt; (2, 3) -&gt; (3, 3) -&gt; (3, 1)이다. 즉, (2, 3)의 상위 병합인 (3, 1)과 (3, 1)에 병합된 모든 셀을 초기화시키면 된다.그리고 병합 해제 전 (2, 3)은 (3, 1)의 값을 갖고 있었다. arr[2][3]에는 병합 명령을 수행하며 arr[3][1]의 값이 들어있다. 그러므로 arr[2][3]의 본인 값 그대로 유지해야 한다.function unmerge(r, c) { // (r, c)의 값은 유지하기 위해 임시 변수에 넣어둔다. let value = arr[r][c]; // (r, c)가 참조하는 셀의 위치를 담아둔다. let change_pointer = parent[r][c]; for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { // (r, c)가 참조하는 parent를 참조하는 모든 셀의 값을 초기화한다. if (parent[i][j] === change_pointer) { // 참조의 경우 본인 위치로 갱신하고, parent[i][j] = `${i},${j}`; // 값의 경우 빈 값을 의미하는 \"EMPTY\"로 갱신한다. arr[i][j] = \"EMPTY\"; } } } // 병합 해제 전 값을 가진 경우 그 값을 그대로 유지해야 하므로 갱신한다. arr[r][c] = value;}4️⃣ 첫 번째 UPDATE 명령에 대한 기능을 구현하자.UPDATE r c value 명령은 (r, c)를 value로 갱신시킨다. 이 때, (r, c)가 다른 셀에 병합된 상태라면 (r, c)가 아닌 상위 병합의 값을 갱신해야 한다. 그리고 상위 병합에 병합된 모든 셀들의 값도 변경해야 한다. (병합 명령 시 상위 병합 값을 본인 셀에 저장해뒀기 때문에 상위 병합 값이 변한다면 본인도 변경해줘야 하기 때문이다.)위 그림에서 (2, 2), (2, 3), (3, 3)은 모두 (3, 1)에 병합된 상태다. 이 때, UPDATE 2 2 🍎 명령은 (2, 2)뿐만 아니라 (2, 2)의 상위 병합인 (3, 1)과 (3, 1)에 병합된 (2, 3)과 (3, 3)까지 모두 🍎으로 갱신해야 한다.UPDATE 명령을 수행해도 병합 관계가 변하는 것은 아니다. 값만 변경되는 것이다.function update_1(r, c, value) { for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { // (r, c)가 참조하는 셀을 참조하는 모든 셀의 값은 수정되어야 한다. if (parent[i][j] === parent[r][c]) arr[i][j] = value; } }}5️⃣ 두 번째 UPDATE 명령에 대한 기능을 구현하자.UPDATE value1 value2는 value1을 가진 셀을 value2로 갱신해주기만 하면 된다. 이 때도 병합 관계는 고려하지 않아도 된다.function update_2(value1, value2) { for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { if (arr[i][j] === value1) arr[i][j] = value2; } }}6️⃣ 마지막으로 PRINT 명령에 대한 기능을 구현하자.문제의 최종 답은 PRINT 명령 시 해당 셀의 값을 반환하는 것이다. 따라서 PRINT r c 명령이 수행되면 arr[r][c]을 반환하면 된다.병합 관계를 고려하지 않고 (r, c)가 가지고 있는 값을 반환할 수 있는 이유는 병합 명령을 수행할 때, 상위 병합 값을 본인 셀에 담고 있기 때문이다.const answer = [];function print(r, c) { answer.push(arr[r][c]);}7️⃣ 명령어를 switch문으로 하나씩 수행하고 실행 결과를 임시 배열에 담아 return하면 된다.function solution(commands) { const answer = []; commands.forEach((command) =&gt; { const [cmd, option1, option2, option3, option4] = command.split(\" \"); switch (cmd) { case \"UPDATE\": if (option3) { update_1(option1, option2, option3); } else { update_2(option1, option2); } break; case \"MERGE\": merge(option1, option2, option3, option4); break; case \"UNMERGE\": unmerge(option1, option2); break; case \"PRINT\": print(option1, option2); break; } }); return answer;}🏹 코드function solution(commands) { const answer = []; const parent = Array.from({ length: 51 }, (_, i) =&gt; Array.from({ length: 51 }, (_, j) =&gt; `${i},${j}`) ); const arr = Array.from({ length: 51 }, () =&gt; Array.from({ length: 51 }, () =&gt; \"EMPTY\") ); function update_1(r, c, value) { for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { if (parent[i][j] === parent[r][c]) arr[i][j] = value; } } } function update_2(value1, value2) { for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { if (arr[i][j] === value1) arr[i][j] = value2; } } } function merge(r1, c1, r2, c2) { if (arr[r1][c1] === \"EMPTY\" &amp;&amp; arr[r2][c2] !== \"EMPTY\") [r1, c1, r2, c2] = [r2, c2, r1, c1]; let new_value = arr[r1][c1]; let change_pointer = parent[r2][c2]; for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { if (parent[i][j] === change_pointer) { parent[i][j] = parent[r1][c1]; arr[i][j] = new_value; } } } } function unmerge(r, c) { let value = arr[r][c]; let change_pointer = parent[r][c]; for (let i = 1; i &lt;= 50; i++) { for (let j = 1; j &lt;= 50; j++) { if (parent[i][j] === change_pointer) { parent[i][j] = `${i},${j}`; arr[i][j] = \"EMPTY\"; } } } arr[r][c] = value; } function print(r, c) { answer.push(arr[r][c]); } commands.forEach((command) =&gt; { const [cmd, option1, option2, option3, option4] = command.split(\" \"); switch (cmd) { case \"UPDATE\": if (option3) { update_1(option1, option2, option3); } else { update_2(option1, option2); } break; case \"MERGE\": merge(option1, option2, option3, option4); break; case \"UNMERGE\": unmerge(option1, option2); break; case \"PRINT\": print(option1, option2); break; } }); return answer;}👩‍🌾 새로 알게 되었거나 중요한 포인트구글링하면서 이 문제를 union-find로 해결할 수 있다는 블로그 글을 읽었다. union-find가 뭔지 몰랐는데 이 방식이 유사한게 아닌가 생각된다.상위 병합의 값을 가져와야 할 때, 상위 병합의 값을 찾으러 가서 반환하지 않고 병합 당시에 그 값을 본인이 가지고 있으므로써 시간을 절약할 수 있다.union-find는 조금 더 알아봐야겠다. 필요하다면 아래 블로그들을 참고하자. 🐝 참고 서로소 집합(Disjoint Set) &amp; 유니온 파인드(Union find) [알고리즘] Union-Find 알고리즘 - Heee’s Development Blog velog(woohoo.log) - [알고리즘] union-find 알고리즘" }, { "title": "📸 2023-01-10", "url": "/posts/230110TIL/", "categories": "TIL", "tags": "블로그", "date": "2023-01-10 18:43:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 블로그에 레퍼런스 조회 페이지 추가🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?블로그에 레퍼런스 조회 페이지 추가구독된 서비스들에서 보내주는 이메일에도 좋은 글들이 정말 많은데 읽어야지 하면서 미뤄두다가 놓치게 된다. 그리고 공부하다보면 정말 많은 블로그의 글들을 찾게 된다. 역시 좋은 글이다 싶어서 탭을 열어뒀다가 이게 쌓여서 크롬은 탭이 30개씩 열려있다. 계속 쌓아두다가 날린적도 있다😂.읽으려고 했던 글, 정말 도움이 되는 글이라 다음에 또 읽어봐야 할 글, 또 필요할 거 같은 글들을 블로그에 정리해두기로 했다.페이지 추가하는건 예전에 페이지 추가했던 방법을 그대로 사용했다.페이지 상단에는 태그를, 하단에는 그 태그와 관련된 포스트 목록이 나오게 구성하였다.우선 레퍼런스들의 정보를 json으로 정리했다. 그리고 async로 받아와서 HTML 태그를 붙였다.[ { \"title\": \"리액트 공식문서\", \"tags\": \"리액트, 자바스크립트\", \"url\": \"https://ko.reactjs.org/\" }]각 레퍼런스 아이템들은 노션의 북마크처럼 표현하고 싶었다.URL로 프리뷰 정보를 알아내는 link-preview-js라는 라이브러리를 발견했다. 이걸 내 레파지토리에 설치하고 사용하려고 했는데 잘 되지 않아서 우선 보류했다. 방법이야 찾을 수 있겠지만 목록은 더 많아질 것인데 이미지를 불러오는 것이 옳은지 고민도 되기 때문이다. 프리뷰 정보를 얻어낼 수 있는 라이브러리를 알게 된 것만으로도 새롭다. 간단한 페이지이긴 하지만 이제 만든 페이지라서 레이아웃은 계속 변하지 않을까 싶다." }, { "title": "📸 2023-01-08", "url": "/posts/230108TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트, 리액트, SyntheticEvent", "date": "2023-01-08 21:50:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 이모티콘 할인행사 - 자바스크립트 인프콘 2022 다시보기 요즘 공부하기 싫거나 시간이 남을 때 듣고있다. 인터랙티브 웹 개발 제대로 시작하기 - 섹션 1. CSS 변환과 애니메이션 이전에 공부했는데 기억이 안나서 복습 transition과 transform 사용하기 참고! 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 프로그래머스 이모티콘 할인행사 - 자바스크립트를 푸는데 거의 이틀 걸렸다. 완전탐색으로 풀어야 한다는 힌트를 얻고도 어떻게 구현할지 생각하는 것에 많은 시간을 소요했다. 다른 개발자들의 답안을 봤는데 더 간단한데 그걸 완전히 이해하는데도 시간이 걸렸다. 남이 작성한 코드는 언제 봐도 어렵다…🌟 내일은 어떻게 해보고 싶으세요? 인터랙티브 웹 개발 제대로 시작하기 강의를 더 들으면서 CSS랑 자바스크립트 공부해야지리액트 이벤트 동작 원리에 관한 몇 가지 정보 - SyntheticEvent연정이가 리액트의 이벤트 작동 원리에 관한 글을 하나 보내줬다. 다 이해하지는 못했지만 이제까진 이벤트 리스너를 붙인 요소에 그대로 붙을줄 알았는데 그게 아니라는걸 처음 알았다. 다음에 더 깊게 알게 되면 도움이 될까하여 간략하게 정리해둔다. ✅ 리액트 17버전부터 이벤트 핸들러를 Document 레벨이 아닌 리액트 트리가 렌더되는 root DOM container에 붙인다. ✅ NativeEvent를 그대로 사용하는 것이 아닌 SyntheticEvent 객체를 이용해서 NativeEvent를 감싸는 방식을 사용한다. ✅ NativeEvent 이름과 리액트 이벤트 핸들러의 Property를 매핑해주고 전체 NativeEvent를 순회하며 각 이벤트에 리액트 이벤트 핸들러를 등록한다. =&gt; 이 단계는 최초 렌더링이 되기 전에 이루어지므로 root DOM Node에 모든 이벤트 핸들러가 등록되어 있다. ✅ 이벤트가 발생하면 이벤트 객체로부터 해당 이벤트를 발생시킨 node를 찾고, 해당 node부터 root node까지 트리를 순회하면서 매칭되는 이벤트를 발견할 때마다 특정 큐에 저장한다. ✅ root node에 도달하면 큐에 들어간 순서대로 리스너 함수가 실행된다. 🐝 참고 콴다 팀블로그 - React Deep Dive— React Event System (1) 리액트(React)의 이벤트 핸들러(Event Handler) SyntheticEvent — nativeEvent" }, { "title": "프로그래머스 이모티콘 할인행사 - 자바스크립트", "url": "/posts/programmers-150368/", "categories": "코딩테스트", "tags": "코테, 프로그래머스, 완전탐색", "date": "2023-01-08 14:30:25 +0900", "snippet": "📄 문제프로그래머스 &gt; 2023 KAKAO BLIND RECRUITMENT &gt; 이모티콘 할인행사구현해야 하는 것은이모티콘 종류와 유저들의 구입 정보가 주어졌을 때, 이모티콘 플러스 가입자와 이모티콘 판매액을 최대로 늘리는 경우를 구해야 한다.여기서 중요한 것은 목표의 우선순위다. 이모티콘 플러스 서비스 가입자를 최대한 늘리는 것. 이모티콘 판매액을 최대한 늘리는 것.이모티콘 플러스 가입자가 3명, 판매액이 10,000원보다 이모티콘 플러스 가입자가 5명, 판매액이 0원이 목표에 부합한다.각 이모티콘의 할인율이 다를 수 있으므로 어떤 이모티콘을 얼마나 할인해줘야 가입자 수와 매출을 극대화시킬 수 있을지 알기 위해서는 각 이모티콘마다 10%, 20%, 30%, 40% 할인율을 다 적용해본 모든 경우의 수를 다 구해봐야 한다.다행히 제한사항을 살펴보면 이모티콘의 종류는 최대 7개다. 모든 경우의 수를 구해도 최대 47(=16384)이다. 완전 탐색으로 모든 경우를 구하기 충분하다. ❗️ 여기서 경우의 수가 최대 47(=16384)라는 것은 할인율을 조합한 경우의 수다. 아래에서 설명하듯 할인율 조합 내에서도 사용자, 이모티콘을 순회하므로 전체 코드 내 반복 횟수가 47(=16384)는 아니다.0️⃣ 구조 확인하기큰 틀은 다음과 같다.순회문은 3번 중첩되어 있다. 가장 외부 반복문은 할인율을 조합한 모든 경우의 수를 순회하기 위함이다. 그 다음으로는 모든 사용자를 순회하고 가장 내부에서 모든 이모티콘을 순회한다. 🔁 할인율 조합별 이모티콘 플러스 가입자와 판매액을 알기 위해 모든 할인율 조합 경우의 수를 순회한다. 🔁 사용자별 이모티콘 구매 정보를 알기 위해 모든 사용자를 순회한다. 🔁 할인율이 적용된 각 이모티콘의 구매 여부와 구매 금액을 알기 위해 모든 이모티콘을 순회한다. 1️⃣ 중복순열을 이용해 모든 경우의 수를 구한다.경우의 수를 구하기 위해서 주의해야 하는 점은 아래 두 가지다. 10,20,30,40이라는 네 개의 숫자를 순서를 고려해서 이모티콘의 갯수만큼 뽑아내야 한다. (이모티콘 A,B가 있을 때 [A 할인율(10), B 할인율(20)]와 [A 할인율(20), B 할인율(10)]는 다르다.) 모든 이모티콘의 할인율이 동일한 경우도 있다. 그러므로 자기 자신의 중복도 허용해야 한다. (이모티콘 A,B가 있을 때 [A 할인율(10), B 할인율(10)]일 수 있다.) 조건 1,2에 따라 중복 순열로 구하기로 했다.이모티콘이 3개(A, B, C)라면 [A 할인율(10), B 할인율(10), C 할인율(10)]부터 [A 할인율(40), B 할인율(40), C 할인율(40)]까지 총 64개의 경우의 수를 얻을 수 있다.const getPermutations = (arr, length) =&gt; { const result = []; if (length === 1) return arr.map((v) =&gt; [v]); arr.forEach((fixed, index, origin) =&gt; { const permutations = getPermutations(origin, length - 1); const attached = permutations.map((res) =&gt; [fixed, ...res]); result.push(...attached); }); return result;};// 👇 EX) 1, 2, 3 중에 2개를 선택하는 경우getPermutations([1, 2, 3], 2); // (9) [[1,1], [1,2], [1,3], [2,1], [2,2], [2,3], [3,1], [3,2], [3,3]]2️⃣ 이모티콘을 할인할 수 있는 모든 경우의 수를 구하고 사용자가 어떤 경우에 이모티콘을 구매할지, 구매한다면 구매 비용은 얼마인지 구해야 한다.1️⃣에서 생성한 getPermutations를 이용해서 이모티콘을 할인하는 경우의 수를 구해야 한다. 각 경우의 수는 이모티콘의 갯수만큼의 요소를 가진 배열 형태다.이모티콘(emoticons)이 [7000,3000,2000,1000,5000]로 주어진다면 getPermutations가 반환하는 2차원 배열의 각 요소는 할인율을 5개 뽑아낸 경우로 이모티콘의 갯수와 무조건 같다. [10,20,30,40,10]의 형태로 주어지고, 이는 첫 번째 이모티콘(7000)은 10% 할인, 두 번째 이모티콘(3000)은 20%, 세 번째 이모티콘(2000)은 30%, 네 번째 이모티콘(1000)은 40% 할인, 다섯 번째 이모티콘(5000)은 10% 할인한다는 의미다.// 🔁 할인율 조합별 이모티콘 플러스 가입자와 판매액을 알기 위해 모든 할인율 조합 경우의 수를 순회한다.getPermutations([10, 20, 30, 40], emoticons.length).forEach((permutation) =&gt; { // permutation : 할인율을 조합한 특정 경우의 수를 담은 배열이다. 이 배열의 길이는 무조건 이모티콘 갯수와 같다. (permutation.length === emoticons.length) // permutation[i]는 emoticons[i]의 할인율이다.});각 경우의 수마다 이모티콘 플러스 가입자와 판매 금액을 계산해야 한다.getPermutations([10, 20, 30, 40], emoticons.length).forEach((permutation) =&gt; { // 👇 permutation의 이모티콘 플러스 가입자 수를 누적하기 위한 변수 let plusUser = 0; // 👇 permutation의 이모티콘 판매액을 누적하기 위한 변수 let sales = 0;});이제 사용자가 어떤 이모티콘을 구매할지 찾아야 한다. 사용자마다 원하는 할인율 기준이 다르기 때문에 모든 사용자가 모든 이모티콘을 확인해야 한다.getPermutations([10, 20, 30, 40], emoticons.length).forEach((permutation) =&gt; { let plusUser = 0; let sales = 0; // 🔁 사용자별 이모티콘 구매 정보를 알기 위해 모든 사용자를 순회한다. users.forEach((user) =&gt; { // 👇 rate : 현재 사용자가 원하는 최소 이모티콘 할인율 // 👇 total : 현재 사용자가 이모티콘 플러스 가입하기로 한 최소 금액 const [rate, total] = user; // 할인율 기준에 부합하여 이모티콘을 구매할 때 구매 금액을 누적하기 위한 변수. let tempAmount = 0; // 🔁 할인율이 적용된 각 이모티콘의 구매 여부와 구매 금액을 알기 위해 모든 이모티콘을 순회한다. emoticons.forEach((emoticon, index) =&gt; { // 현재 이모티콘의 할인율이 사용자가 원하는 할인율과 같거나 커야 구매한다. if (permutation[index] &gt;= rate) { // 이모티콘을 구매한다면 할인율을 적용한 금액을 tempAmount에 누적한다. // 10,20,30,40은 할인율이므로 100에서 할인율을 뺀 값의 백분율로 계산해야 한다. tempAmount += emoticon * ((100 - permutation[index]) / 100); } }); // 한 사용자에 대해 모든 이모티콘을 확인했으므로 tempAmount은 현재 유저가 구매한 이모티콘의 총 금액이다. // total과 같거나 크면 이모티콘 플러스 서비스에 가입자 수에 누적한다. if (tempAmount &gt;= total) { plusUser++; } else { // 이모티콘 플러스 서비스 가입 조건에 부합하지 않는다면 총 매출액에 누적한다. sales += tempAmount; } });});3️⃣ 가장 목적에 부합하는 값을 찾기 위해 모든 경우의 수마다 얻어낸 plusUser와 sales를 임시 객체 담아둔다.이제 경우의 수마다 이모티콘 플러스 가입자 수(plusUser)와 이모티콘 매출액(sales)를 알고 있다. 모든 경우의 수에 대해 plusUser와 sales를 임시 객체 obj에 담아둔다.최우선 순위는 이모티콘 플러스 서비스 가입자를 최대한 늘리는 것이다. 그러므로 plusUser 중 최대값을 찾아야 한다. plusUser의 최댓값이 여러 개 존재하면 그 중 sales가 가장 큰 값을 찾아내는 것이 목적을 최대한으로 달성하는 것이다.plusUser를 obj의 key로 설정하고 value로 빈 배열로 초기화한 뒤에 sales를 이 배열에 쌓아두고 모든 순회가 종료된 후 각각의 최대값을 찾아서 반환한다.const solution = (users, emoticons) =&gt; { const obj = {}; getPermutations([10, 20, 30, 40], emoticons.length).forEach((permutation) =&gt; { let plusUser = 0; let sales = 0; users.forEach((user) =&gt; { // ... }); // 이모티콘 플러스 가입자 수가 가장 큰 값을 얻어야 하므로 가입자 수를 key로 지정하고 빈 배열로 초기화한다. if (!obj[plusUser]) { obj[plusUser] = []; } // 이모티콘 플러스 가입자 수가 동일하고 매출액은 다를 수 있으므로 매출액은 배열의 요소로 쌓아둔다. obj[plusUser].push(sales); }); let maxPlusUser = 0; let maxSales = 0; //Math.max로 obj의 key 중 최대값을 얻는다. 이모티콘 플러스 서비스 가입자를 최대한 늘린 경우인 것이다. Object.keys(obj).forEach((key) =&gt; { maxPlusUser = Math.max(maxPlusUser, key); }); //이모티콘 플러스 서비스 가입자가 가장 많다면 그 다음으로 매출액이 커야 한다. 그러므로 obj[key] 배열에서 최대값을 찾아야 한다. maxSales = Math.max(...obj[maxPlusUser]); return [maxPlusUser, maxSales];};🏹 코드const solution = (users, emoticons) =&gt; { const obj = {}; getPermutations([10, 20, 30, 40], emoticons.length).forEach((permutation) =&gt; { let plusUser = 0; let sales = 0; users.forEach((user) =&gt; { const [rate, total] = user; let tempAmount = 0; emoticons.forEach((emoticon, index) =&gt; { if (permutation[index] &gt;= rate) { tempAmount += emoticon * ((100 - permutation[index]) / 100); } }); if (tempAmount &gt;= total) { plusUser++; } else { sales += tempAmount; } }); if (!obj[plusUser]) { obj[plusUser] = []; } obj[plusUser].push(sales); }); let maxPlusUser = 0; let maxSales = 0; Object.keys(obj).forEach((key) =&gt; { maxPlusUser = Math.max(maxPlusUser, key); }); maxSales = Math.max(...obj[maxPlusUser]); return [maxPlusUser, maxSales];};const getPermutations = (arr, length) =&gt; { const result = []; if (length === 1) return arr.map((v) =&gt; [v]); arr.forEach((fixed, index, origin) =&gt; { const permutations = getPermutations(origin, length - 1); const attached = permutations.map((res) =&gt; [fixed, ...res]); result.push(...attached); }); return result;};⛳️ 더 좋은 해결책할인율을 각기 다르게 조합하는 모든 경우의 수를 구하기 위해서 이전에 조합을 구하는 코드를 참고하여 중복순열을 사용했다. 다른 답안을 보니 더 간단한게 경우의 수를 구하는 방법이 다양했다. 좋은 방법인거 같아서 기록해둔다.프로그래머스 skyshr님의 코드 🐝 참고 [알고리즘] 조합, 순열, 중복순열 - 경우의 수 찾기 by javascript (ft. 모든 경우의 수)" }, { "title": "2022 회고 - 어쩌다 안식년", "url": "/posts/2022retrospect/", "categories": "2022, 회고", "tags": "회고", "date": "2022-12-30 13:55:00 +0900", "snippet": "😨 우선 이전 회고를 다시 읽어보기로 했다.회고를 쓴 후 잊고 있었다.올해 회고를 쓰기 전에 2021 회고와 2022 상반기 회고를 다시 읽어봤다.나름 굳게 다짐한 것들이 있는데 지키지 못해서 반성하게 된다.(회고란 원래 그런 것이니까) 열심히 하겠다고 다짐한대로 살지 못했다.그렇다고 아무것도 안한건 아니다. 난 1년동안 무엇을 했고 무엇을 얻었는가?🤔👩🏻‍💻 주제파악과 부족한 점을 깨닫는 가장 현실적인 방법최종 합격한 회사는 단 한 곳이다. 평균 한 달에 한 곳에는 지원을 하고 테스트를 응시한건데 첫 단계에서 탈락한 회사가 상당수다. 가벼운 마음으로 테스트 해본거라며 기대도 안했다고 넘겼는데 이게 익숙해지면 안되겠다라는 생각이 든다.자비스앤빌런즈 이전에 기록한 코딩테스트 후기, 과제테스트 후기1차로 자바스크립트 과제테스트를 통과하고 2차로 리액트, 타입스크립트를 써서 과제테스트를 볼 기회를 얻었다.이 날 다른 테스트도 있어 이것저것 건드리느라 둘 다 제대로 해내지 못했다. 테스트 종료시간이 다가오니 시간을 효율적으로 사용하지 못한게 정말 아쉬웠다.타입스크립트를 벼락치기한 것도 아쉬웠다. 강의만 사놓고 공부하지 않은 내 잘못이지. 알고리즘 문제가 아니고 리액트와 타입스크립트를 써서 구현하니 재밌었다.신한DS 이전에 기록한 과제테스트 후기상반기 회고를 쓸 때 하반기 목표 중 하나가 면접이다.채용공고와 홈페이지에서 구축사례를 보며 일해보고 싶었다. 그래서 제주살이 중에 서류를 지원했고 운이 좋게도 코딩 테스트 기회도 얻었고 면접까지 봤다. 면접 자체가 너무 오랜만이기도 했고 화상 면접을 처음 하는거라 긴장을 많이 했다. 하고 나니 화상 면접이 훨씬 편한거 같긴 하다.내가 나 자신을 정확히 소개했는지 모르겠다. 매 단계마다 부족했지만 감사하게도 합격을 주셨다. 채용과정에 최선을 다했지만 최종적으로 갈 수 없다고 판단이 되어 거절을 하게 되었다.면접.. 이걸 최소 한 번은 더해야 한다.. 최소.. 한 번.. 언제 올지 모르는 기회를 잡기 위해서는 준비가 되어 있어야 한다.촘촘하게 준비하면 설렘이 두려움을 압도합니다!버킷플레이스프로그래머스 데브매칭으로 얻은 기회다. 데브매칭과 별개로 코딩테스트를 쳐야 했고 응시 일자를 지원자가 선택할 수 있도록 배려해줘서 고마웠다.결론적으로 코딩테스트 문제 중 클린하게 통과한 문제가 하나도 없었고 종료 후에 굉장히 아쉬웠다. 올해 본 테스트중에 답이 가장 궁금했고 내 답안이 너무 아쉬웠다.처음 본 개념도 있고 시간 절약할 수 있는 방법이 도저히 떠오르지 않는데 시간 초과가 나니 답답했다. 탈락 메일을 받고 나서 답안을 제공해주는지 물어볼까 엄청 고민을 했다. 제공하지 않을 거라고 멋대로 판단해서 문의하지는 않았는데 해볼걸 그랬나.. 싶다.코딩테스트를 수행하여 과제비로 오늘의 집 포인트를 받았다. 기분이 나아졌다.🎉 나만의 공간, 우선 미래의 나를 위한 공간, 내 블로그회사 다닐 때부터 만들겠다고 마음속으로만 다짐하던걸 올해 드디어 만들었다. 처음엔 개인 블로그를 생성하지 않아도 되니까 글만이라도 쓰고 정리하자는 마음으로 벨로그를 사용했다.개발자들이 쉽게 접할 수 있는 공간이라는 장점이 막상 글을 쓰려니 부담으로 다가왔다. 글을 멋드러지게 써야할 것만 같고 또 그러고 싶었다. 그래서 완벽하게 끝낸 글이 아니면 모두 비공개 상태에서 작성했고 지금도 공개글보다 비공개로 해두고 매듭짓지 못한 글이 훨씬 많다.그래서 깃헙블로그를 만들었고 TIL도 강박을 가지지말고 자유롭게 써보자 했지만 지금 돌아보니 너무 자유로웠던거 같다…몇 달 동안은 검색 노출도 신청하지 않고 정리만 했다. 한 달 전부터는 내 글도 누군가 검색해서 들어왔으면 좋겠다는 생각에 Google Search Console에 사이트맵을 등록하고 구글 애널리틱스에 사이트 등록해서 통계를 확인하기로 했다.구글링해서 내 글이 나오면 얼마나 기분 좋을까하며 단순하게 시작했지만 성공이라는 글자를 보기까지 한 달이 걸렸다. 다들 시간이 답이라고 기다리라고 했지만 답답한 마음에 사이트맵 재등록을 여러 번 했다. 정말 시간이 답이었나…현재 상황은 아직 검색해도 안나온다. 이건 아직 원인을 찾지 못했다. 이것도 기다려야 하나요?블로그를 시작한건 올해 잘한 일 중에 하나다. 공부하면서 아! 이거 예전에 봤던거랑 비슷한데 뭐였더라하는 것들을 찾아볼 수 있고 이번 회고를 쓰면서도 이전 글을 참고하는중이다😅. 그리고 폰트나 배경을 바꾸고 싶을 때마다 수정할 수 있으니 기분 전환도 되고 만족스럽다.내가 구글링해서 나오는 수준 높은 글들에 비교하기도 했지만 그 분들의 수준을 좇되 압박감을 크게 가지지는 말자. 뱁새가 황새 따라가다 가랑이가 찢어진다.(근데 가랑이 찢어져도 황새 따라가고 싶다.) 내가 먼저 정확히 알고 정리해야 남에게도 공유할 수 있는 것이니.📖 배울게 많다는 것은 그만큼 성장할 여지가 크다. 계속해서 성장하는 중이다.올해는 주로 자바스크립트 문법과 코딩테스트 연습을 많이 했다.올해 강의를 많이 구매했다. 서점을 가면 재밌어보이고 유익해보여 읽어봐야겠다고 메모해둔 책이 많다. 대부분 서점을 나온 후로 기억 속에서 사라진다. 인프런이나 유데미에서도 강의를 찾을 때도 마찬가지다. 평소 궁금했던 내용 또는 흥미로워 보이는 강의가 눈에 많이 들어온다.문제는 이제 내 것이 되고 난 후로 들여다보지 않는다는 것.대부분의 강의는 자바스크립트 또는 그와 관련된 프레임워크(라이브러리)에 관한 것이다. 작년부터 궁금했던 TDD를 알기 위해 시청한 강의도 있다. 물론 전체 강의를 수강해야 하는 것은 아니지만 딱 봐도 거의 초반만 듣다가 끝난게 많다.이대로 두면 그냥 강의 쇼핑 중독자만 되는거다. 이 강의들은 내 지식이 되어주기 위해 기다리고 있다. 나는 시간만 내서 받아먹기만 하면 된다. 궁금해하며 구입했던 마음가짐을 생각하며 내 것으로 만들자!위 강의들의 주제 외에도 배워야 하는 것, 배우고 싶은 것이 많다.아무것도 하지 않아도 조금만 공부해도 1년이 얼마나 빠른지 몸소 느꼈기 때문에 정신차려야한다.📚 많이 읽는 것보다 하나를 제대로 읽는게 중요하다고 하지만 권수만 많다.올해는 작년에 비해 책을 많이 읽지 못했다고 생각했는데 IT 관련 서적을 많이 읽었다. 대부분 출간한 뒤 베스트셀러에 오르거나 개발자 커뮤니티에서 언급되어 호기심에 읽어본 책들이다. 끝까지 다 읽지 못한 책들도 있다.올해의 베스트 책을 꼽자면 김초엽 작가의 지구 끝의 온실이다. (프로젝트 헤일메리와 용호상박이지만 이건 작년 말에 읽었으므로…) 굉장히 몰입하게 되는 장편 소설이다. 스토리도 신선하고 흥미로웠으며 인물들의 감정을 표현하는 방법이 감성적이고 마음에 와닿았다. 그래서 다 읽은 후 여운이 오래 남았다. 단편소설을 주로 쓰시지만 개인적으로 계속 장편소설을 집필해주셨으면 한다..ㅎ🍊 한 달을 순식간에 보내는 방법, 제주에 한 달 머무르기7월 중순에 반충동적으로 에어비앤비에서 숙소를 바로 잡았다. 언젠간 해보고 싶던 버킷리스트였지만 2주 뒤에 가겠다고 예약을 할 줄이야. 그것도 휴가철인 8월에 말이다.하지만 당장 가고 싶었다. 뚜벅이로 다닐 거니까 숙소는 시내로 잡으면 되겠다. 그게 끝이었다. 제주 여행을 가본적이 없기 때문에 남들은 다 아는 동쪽엔 뭐가 있고 서쪽엔 뭐가 있는지도 모르고 무작정 떠났다.너무 모르는 상태로 다녀와 못가본 곳이 굉장히 많지만 후회는 없다. 먹는 것보다 보러 다니는 것이 즐거웠다.조금 아쉬웠던건 동생과 여행 일정을 잡은 9월 첫 주에 태풍 힌남노 덕분에 거의 가보지도 못했다.제주에서 한 달 살고 왔다고 하면 다들 부러워하며 뭐했냐고 물어보는데 딱히 특별한 활동을 하지 않았다고 하면 바보로 본다. 나도 어느정도 동의한다.한 달은 너무나도 짧았고 제주는 정말 아름다웠다. 왜 우리나라 1등 관광지인지 일주일도 되지 않아 알게 되었다. 여유가 된다면 또 다시 제주를 가고싶다. (운전을 배워서…)⏰ 나는 컴퓨터를 하는 동안 어떤 프로그램을 얼마나 사용하는가 링크 : https://github.com/LemonScone/check-it-out일렉트론과 리액트로 만든 시간 추적 데스크톱 애플리케이션이다. 완벽하게 끝내지는 못했지만 이 프로젝트 덕분에 일렉트론을 처음 사용해봤는데 늘 그렇듯 초기 설정부터 쉽지는 않았다. 리액트처럼 자료가 많은 것도 아니라 뭔가 찾을 때 다소 어려움이 있었지만 시간 추적이라는 주 기능은 구현할 수 있었다. 그리고 재밌다. 아주 작은 프로젝트였지만 프론트엔드와 백엔드를 건드려볼 수 있었다.(기억에 남는건 메인과 렌더러 사이의 ipc통신!)만들기 위해 참고했던 프로젝트가 있는데 Tockler이다. 우리 프로젝트처럼 일렉트론과 리액트를 사용했고 코드를 참고하기에 깔끔하고 좋았다.해당 코드를 분석한 포스트를 벨로그에 임시저장해뒀는데 이것도 마무리 짓지 못해 비공개로 처리해뒀다.. 기회가 된다면 마무리해야겠다.🐰 2023년에는특별한 다짐은 없고 지금 당장 머릿속에 떠오르는걸 공부해야겠다. 그리고 더 단단한 개발자가 되어 원하는 목표를 이뤄보자.의지가 약해질 때면 동기부여를 위해 열심히 사는 사람들의 글이나 영상을 본다. 요즘은 유투브 겨울서점과 인프콘 2022를 다시보고있다.무척 열심히 사는 사람과 나와 같은 직종을 선택한 사람들의 다양한 이야기들은 늘 다시 의지를 잡는 것에 도움을 준다.유독 보내기 싫은 2022년의 마침표를 찍고 새로운 한 해를 잘 버티자!2023년 회고를 작성할 때에는 더 멋있는 개발자가 되어 있길 바라며 Change isn’t suppose to be comfortable or convenient If you want change, be prepared to feel awkward “변화는 안정성이나 편리함을 동반하지 않는다. 변화를 원하거든, 불편함을 느낄 각오부터 해라.”" }, { "title": "📸 2022-12-29", "url": "/posts/221229TIL/", "categories": "TIL", "tags": "자바스크립트, nextJS, ChatGPT", "date": "2022-12-29 17:17:49 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? nextJS 기본 알아보기 ChatGPT 써보기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? nextJS의 기본 사용법을 알게 되었지만 이제 첫 발만 뗀 격이다. 어떻게 돌아가는지, 원리가 궁금하다…🌟 내일은 어떻게 해보고 싶으세요? nextJS 더 알아보기NextJS 시작하기nextJS는 예전부터 너무 많이 들은 개념이다. 다음에 공부해보자고 미루다가 오늘 노마드코더 NextJS 시작하기 강의를 들으며 아주 기본 개념과 사용법을 알아봤다.이론만 알고 있을 땐 리액트로 짠 소스를 서버에서 어떻게 동작시켜서 그걸 브라우저한테 html로 보내준다는거지?라는 궁금증이 늘 있었다. 아직 이 강의만 봤을 때에 해소되지 않는다. 하지만 NextJS가 내 생각보다 더 사용하기 편리하고 쉬울 거 같다는 느낌이 든다. 하나의 파일에 export default로 컴포넌트를 생성하면 파일명이 경로가 되어 컴포넌트가 해당 페이지의 내용으로 보여진다. 기존 리액트만 사용했을 때에는 링크를 생성하기 위해 리액트 라우터 라이브러리를 사용해야 한다. SSR, 리액트 코드가 브라우저에서 실행되는 것이 아니라 동작 결과를 서버에서 가져온다. 미리 동작시켜 얻어낸 html 파일을 서버가 브라우저로 보내준다. 그렇다고 렌더링된 후에 동적 변화가 불가능한 것은 아니다. next.js는 프레임워크다. NextJS가 정해둔 규칙에 따라 코드를 작성하면 우리는 원하는 결과를 받을 수 있다. 공식 문서와 아래 블로그 참고해서 더 알아보기 Next.js 공식 문서 next.js 기본 개념 알아보기ChatGPT 체험기여기저기서 ChatGPT, ChatGPT하길래 그게 뭔데 하며 사용해봤다. 유투브나 블로그 등에서 신기하다고 생각했지만 막상 사용해보니 진짜 신기했다. 한국말은 못알아들을까봐 대부분 영어로 질문을 했는데 어디 공식 사이트에서 뽀려온건가… 아님 누가 등록해둔 답변인가 싶을만큼 깔끔하고 정확하게 원하는 내용을 알려줬다.유투브 나도코딩의 ChatGPT, 개발의 새로운 장을 여네요 (무료일 때 꼭 경험해보세요)을 참고해서 여러 기능을 써봤다.내 코드를 보내주며 다른 언어로 바꿔달라거나 코드 리뷰를 해달라고 했다. 잘 알아듣는다. 코딩 테스트 공부를 하며 구글링을 할 때 내가 원하는 코드로 짠 답변이 없거나 다른 언어로 된 답변인데 이거 내가 쓰는 언어로 써서 제출하고 싶을 때가 있다. 그 때 다른 언어로 코드를 변경해주는 기능이 도움이 많이 될 거 같다.아직 많이 사용해본 것은 아니지만 주석을 달아달라거나 한국어로 답변을 받으면 답변이 끊긴다.아직 github copilot을 사용해보지 않았고, 달리(DALL-E), GPT-3라는 것도 처음 알게 되었는데 점점 인공지능 챗봇의 개발 소식의 빈도가 점점 더 높아진다. 노션에서도 Notion AI라는 기능을 도입하려고 한다.점점 신기한 세상이 되어간다… 내 일자리가 없어질까하는 두려움보다는.. 인공지능의 학습 능력이 갖고싶다… 🐝 참고 비개발자의 눈으로 살펴보는 ChatGPT 유투브 나도코딩 - ChatGPT, 개발의 새로운 장을 여네요 (무료일 때 꼭 경험해보세요) 유투브 노마드 코더 - 요즘 인공지능 미쳤습니다.. 현직 개발자 반응! 유투브 노마드 코더 - 완젼 미쳐버린 노션 AI 의 능력….!" }, { "title": "📸 2022-12-20", "url": "/posts/221220TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트", "date": "2022-12-20 20:17:49 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 코딩 테스트 공부 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 요즘 ChatGPT가 유투브나 IT 관련 메일, 블로그에 많이 언급된다. 뭔지 찾아봐야겠다." }, { "title": "프로그래머스 코딩 테스트 공부 - 자바스크립트", "url": "/posts/programmers-118668/", "categories": "코딩테스트", "tags": "코테, 프로그래머스, DP, 동적계획법", "date": "2022-12-20 15:35:03 +0900", "snippet": "📄 문제프로그래머스 &gt; 2022 KAKAO TECH INTERNSHIP &gt; 코딩 테스트 공부구현해야 하는 것은문제를 풀거나 공부로 알고력과 코딩력을 키워 주어진 문제를 다 풀 수 있는 최단 시간을 구해야 한다.주어진 문제를 다 풀기 위해서는 문제 목록에 있는 알고력과 코딩력에서 각각 최대값을 가져야 한다.1️⃣ 최대 알고력과 최대 코딩력을 구한다.매개변수에서 가장 큰 값을 가지는 알고력과 코딩력을 구하자. 매개변수 중 하나인 problems가 아닌 모든 매개변수 중에서 최대 값을 구해야 한다. 초기 알고력(alp)과 초기 코딩력(cop)이 problems의 최대 알고력과 최대 코딩력보다 클 수 있기 때문이다.예를 들어 alp = 10, cop = 20, problems = [[1, 1, 2, 1, 2], [3, 5, 1, 2, 4]]라고 주어지면 초기 값이 풀어야 하는 문제에서 요구하는 능력보다 크다. (이 경우에는 어떠한 능력도 키우지 않아도 모든 문제를 해결할 수 있기 때문에 0을 반환한다.)problems 배열의 요소 중 최대 값을 찾기 위해서 reduce 함수를 사용하되 초기 값을 [alp, cop]로 설정한다.const [maxAlp, maxCop] = problems.reduce( (acc, cur) =&gt; { return [Math.max(acc[0], cur[0]), Math.max(acc[1], cur[1])]; }, [alp, cop]);2️⃣ 특정 알고력과 코딩력을 얻을 수 있는 최단 시간을 저장할 2차원 배열을 선언하고 초기화한다. dp[i][j] : (알고력 i, 코딩력 j) 상태에 도달하는 데 필요한 최단 시간위의 조건을 충족하는 2차원 배열 dp에서 dp[maxAlp][maxcop]이 우리가 최종적으로 찾아야 하는 답이다.alp에서부터 maxAlp까지, cop에서부터 maxCop까지 각 상태에 도달하는 데 필요한 최단 시간을 각각 구해보자. 배열 요소의 초기값은 150으로 초기화한다.초기값이 150인 이유는 0 ≤ alp,cop ≤ 150이기 때문이다. 최단 시간을 구할 것이기 때문에 배열에 들어올 수 있는 최대값을 초기 상태로 두고 갱신해야한다. alp = 0, cop = 0, problems = [[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]]최대 알고력은 10(4번째 문제), 최대 코딩력은 11(3번째 문제)이다. dp[10][11]이 우리가 구해야 하는 답이다.아무것도 계산하지 않은 상태에서 알 수 있는건 dp[alp][cop]의 값은 0이라는 것이다. (현재 알고력, 코딩력이므로 도달하는 데 필요한 시간은 0이다.)const dp = Array.from({ length: maxAlp + 1 }, () =&gt; Array.from({ length: maxCop + 1 }, () =&gt; 150));dp[alp][cop] = 0;dp를 선언하고 초기화한 상태는 아래와 같다.3️⃣ 현재 알고력, 코딩력부터 시작하여 최대 알고력, 코딩력을 구해보자.알고력 또는 코딩력을 키우기 위한 방법은 (1) 공부 또는 (2) 문제 풀기다.(1) 공부알고력 또는 코딩력을 1만큼 높이기 위해서 1의 시간이 필요하다.현재 알고력 0, 코딩력 0이다. 알고력만 1 키우려면 1만큼의 시간이 필요하고, 코딩력만 1 키우려면 1만큼의 시간이 필요한 것이다. 배열로는 dp[1][0]와 dp[0][1]은 1이다. dp[i][j] = (dp[i - 1][j] 또는 dp[i][j -1]) + 1 이다.이를 이용해서 dp[alp][cop]에서 dp[maxAlp][maxcop]까지 필요한 공부 시간을 저장한다.for (let i = alp; i &lt;= maxAlp; i++) { for (let j = cop; j &lt;= maxCop; j++) { let minAlp = Math.min(i + 1, maxAlp); let minCop = Math.min(j + 1, maxCop); dp[minAlp][j] = Math.min(dp[minAlp][j], dp[i][j] + 1); dp[i][minCop] = Math.min(dp[i][minCop], dp[i][j] + 1); //Math.min을 제거하면 아래와 같다. //dp[i + 1][j] = dp[i][j] + 1; //dp[i][j + 1] = dp[i][j] + 1; }}반복문이 중첩되었고 Math.min 함수가 여러 번 사용되어 복잡해보이지만 dp[i][j] 값으로 dp[i + 1][j]와 dp[i][j + 1]에 dp[i][j] + 1을 할당하고 있다.3~4줄에서 Math.min을 사용한 이유는 목표치인 maxAlp, maxCop를 초과하게 되면 시간 초과나 세그먼트 폴트와 같이 예상치 못한 런타임 오류를 일으킬 수 있으므로 초과하게 되면 maxAlp, maxCop에 해당하는 값을 갱신하도록 한다.5~6줄도 마찬가지로 목표치가 초과하는 것을 방지하기 위해 Math.min으로 한계를 지정한다. 초기값에서 목표치까지는 현재까지 걸린 시간에 +1을 해준다.공부로 알고력 i, 코딩력 j에 도달하는 데 걸리는 시간은 아래와 같다.(2) 문제 풀기problems의 원소는 [alp_req, cop_req, alp_rwd, cop_rwd, cost]의 형태로 이루어져 있습니다.모든 문제를 다 확인해야 하므로 problems를 순회해야한다. 현재 알고력, 코딩력으로 풀 수 있으면 해당 문제를 풀었을 때 증가하는 알고력(alp_rwd), 코딩력(cop_rwd)만큼 얻을 수 있다.즉, dp[현재 알고력 + alp_rwd][현재 코딩력 + cop_rwd]까지 능력을 키우기 위해 필요한 시간(cost)과 (1) 공부로 구한 값 중에서 최단 시간을 구해야 하므로 Math.min으로 최솟값을 저장한다.for (let i = alp; i &lt;= maxAlp; i++) { for (let j = cop; j &lt;= maxCop; j++) { //... problems.forEach((problem) =&gt; { // 문제에서 요구하는 알고력, 코딩력 이상의 능력이 필요하므로 i,j는 alp_req, cop_req와 같거나 커야 한다. if (i &gt;= problem[0] &amp;&amp; j &gt;= problem[1]) { minAlp = Math.min(maxAlp, i + problem[2]); minCop = Math.min(maxCop, j + problem[3]); //현재 알고력 i, 코딩력 j로 problem을 푸는 경우 또는 공부로 키우는 경우 중 최소값을 선택한다. dp[minAlp][minCop] = Math.min( dp[minAlp][minCop], dp[i][j] + problem[4] ); //Math.min을 제거하면 아래와 같다. //minAlp = i + problem[2]; //minCop = j + problem[3]; //현 시점에서 dp[minAlp][minCop]는 공부로 도달하는 데 걸리는 시간이다. //dp[minAlp][minCop] = Math.min(dp[minAlp][minCop], dp[i][j] + problem[4]); } }); }}4️⃣ 위에서 언급했듯이 이중 for문은 초기 (알고력, 코딩력)에서 최대 (알고력, 코딩력)까지 각 능력에 도달하기 위해 필요한 최단 시간을 2차원 배열을 통해 저장한다.그러므로 이중 for문이 종료되면 dp[maxAlp][maxcop]에 문제에서 최종적으로 요구하는 값, 모든 문제를 풀 수 있는 알고력과 코딩력을 얻기 위한 최단시간이 저장되어 있다.return dp[maxAlp][maxCop];🏹 코드const solution = (alp, cop, problems) =&gt; { const [maxAlp, maxCop] = problems.reduce( (acc, cur) =&gt; { return [Math.max(acc[0], cur[0]), Math.max(acc[1], cur[1])]; }, [alp, cop] ); const dp = Array.from({ length: maxAlp + 1 }, () =&gt; Array.from({ length: maxCop + 1 }, () =&gt; 150) ); dp[alp][cop] = 0; for (let i = alp; i &lt;= maxAlp; i++) { for (let j = cop; j &lt;= maxCop; j++) { let minAlp = Math.min(i + 1, maxAlp); let minCop = Math.min(j + 1, maxCop); dp[minAlp][j] = Math.min(dp[minAlp][j], dp[i][j] + 1); dp[i][minCop] = Math.min(dp[i][minCop], dp[i][j] + 1); problems.forEach((problem) =&gt; { if (i &gt;= problem[0] &amp;&amp; j &gt;= problem[1]) { minAlp = Math.min(maxAlp, i + problem[2]); minCop = Math.min(maxCop, j + problem[3]); dp[minAlp][minCop] = Math.min( dp[minAlp][minCop], dp[i][j] + problem[4] ); } }); } } return dp[maxAlp][maxCop];}; 🐝 참고 2022 테크 여름인턴십 코딩테스트 해설 [Swift] 2022 KAKAO TECH INTERNSHIP" }, { "title": "📸 2022-12-16", "url": "/posts/221216TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트", "date": "2022-12-16 18:53:49 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 N으로 표현 - Javascript 내용 보충하기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 저번주에 풀고 정리를 안한 코딩테스트 문제들 정리하기..!" }, { "title": "프로그래머스 N으로 표현 - 자바스크립트", "url": "/posts/programmers-42895/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-12-12 15:18:03 +0900", "snippet": "📄 문제프로그래머스 N으로 표현구현해야 하는 것은정해진 한 자리 수(N)와 사칙연산을 이용해서 문제에서 요구한 특정 수(number)를 표현할 때 N을 최소로 사용한 횟수를 구해야 한다.중요한 제한사항은 아래와 같다. 최솟값이 8보다 크면 -1을 return 합니다.N을 최소 1회, 최대 8회 사용하여 사칙연산자와 조합해서 만든 연산식의 몫 중에 원하는 값이 있는지 확인하면 된다. 최소 횟수를 구해야 하므로 1회 사용했을 때 얻을 수 있는 값을 확인해보고 없다면 2회 사용한 연산을 확인해보고 없다면 3회 사용한 연산을 확인해보는 식으로 8회까지만 진행하자. N이 9번 들어가서 number를 구할 수 있어도 신경쓰지 않아도 된다.한 자리 숫자와 사칙연산을 이용해서 수를 표현하는 방법은 크게 두 가지다. (1)수학적으로 계산하기와 (2)문자로 인식 후 이어붙이기다.(1)은 사칙연산을 말한다. 예로 1을 두 번 사용하여 표현할 수 있는 연산식은 1 + 1, 1 - 1, 1 * 1, 1 / 1이다. (2)는 문자로 인식해서 현재 횟수만큼 반복하면 된다. 1을 두 번 이어붙인 11은 (2)다. 여기서 알 수 있는 것은 (2)의 방식은 횟수별로 하나의 경우의 수만 얻을 수 있다는 것이다.문제에 나온 예시를 자세히 살펴보자. 5와 사칙연산(+,-,*,/)를 이용해서 12라는 값을 구해야 한다.5를 한 번만 사용하면 연산식을 얻을 수 없다. 따라서 (2)의 방법으로 5라는 자기 자신만 얻을 수 있다. 한 번만 사용한 값들 중에는 12가 존재하지 않는다.이제 5를 두 번 사용할 때 경우의 수를 알아보자. (1)의 방식으로 5 + 5=10, 5 - 5=0, 5 * 5=25, 5 / 5=1, (2)의 방식으로 N을 2번 붙여서 만든 55까지 총 5가지다. 이번에도 12가 존재하지 않는다.두 번까진 간단하게 생각해볼 수 있지만 세 번부터는 복잡해진다.5를 세 번 사용한 사칙연산 경우의 수는 아래 표와 같다. 표의 머리글(헤더)은 5를 두 번 사용하여 표현할 수 있는 경우의 수다.언듯 보면 복잡해보이지만 형광펜으로 강조한 부분을 기준으로 사칙연산이 수행한 경우의 수를 나열한 것이다. &nbsp; 5 + 5 5 - 5 5 * 5 5 / 5 55 + (5 + 5) + 5 = 15 (5 - 5) + 5 = 5 (5 * 5) + 5 = 30 (5 / 5) + 5 = 6 55 + 5 = 60 5 + (5 + 5) = 15 5 + (5 - 5) = 5 5 + (5 * 5) = 30 5 + (5 / 5) = 6 5 + 55 = 60 - (5 + 5) - 5 = 5 (5 - 5) - 5 = -5 (5 * 5) - 5 = 20 (5 / 5) - 5 = -4 55 - 5 = 50 5 - (5 + 5) = -5 5 - (5 - 5) = 5 5 - (5 * 5) = -20 5 - (5 / 5) = 4 5 - 55 = -50 * (5 + 5) * 5 = 50 (5 - 5) * 5 = 0 (5 * 5) * 5 = 125 (5 / 5) * 5 = 5 55 * 5 = 125 5 * (5 + 5) = 50 5 * (5 - 5) = 0 5 * (5 * 5) = 125 5 * (5 / 5) = 5 5 * 55 = 125 / (5 + 5) / 5 = 2 (5 - 5) / 5 = 0 (5 * 5) / 5 = 5 (5 / 5) / 5 = 0 55 / 5 = 11 5 / (5 + 5) = 0 5 / (5 - 5) = Inf 5 / (5 * 5) = 0 5 / (5 / 5) = 5 5 / 55 = 0 5 + 5열의 첫 번째 행((5 + 5) + 5 = 15)과 두 번째 행(5 + (5 + 5) = 15)은 같은 연산자를 같은 횟수로 사용하여 같은 값을 반환하는데 두 번씩 계산하는 이유는 뭘까?사칙연산에서 더하기(+)와 곱하기(*)는 결합법칙이 성립하지만, 빼기(-)와 나누기(/)는 결합법칙이 성립하지 않기 때문이다. 따라서 연산자 기준으로 위치를 바꾸면 다른 값을 도출한다. 두 번째 행((5 + 5) - 5 = 5)과 여섯번째 행(5 - (5 + 5) = -5)도 같은 연산자를 같은 횟수만큼 사용하지만 다른 값을 반환한다. 결합법칙이란 한 식에서 연산이 두 번 이상 연속될 때, 앞쪽의 연산을 먼저 계산한 값과 뒤쪽의 연산을 먼저 계산한 결과가 항상 같을 경우 그 연산은 결합법칙을 만족한다고 한다. (2 + 3) + 5 = 2 + (3 + 5) =&gt; 결합법칙이 성립한다. (8 - 7) - 3 ≠ 8 - (7 - 3) =&gt; 결합법칙이 성립되지 않는다. 출처 : 위키백과따라서 N을 두 번 사용한 연산식에 다시 사칙연산을 수행하면 N을 세 번 사용한 경우의 수를 얻을 수 있다. 주의할 점은 연산자 기준으로 양쪽 피연산자 자리를 바꿔서 동일한 연산을 수행해야 한다. N을 세 번 사용하여 수를 표현하는 경우의 수 = { N을 두 번 사용한 경우의 수 }{ +, -, *, / }{ N } ∪ { N }{ +, -, *, / }{ N을 두 번 사용한 경우의 수 }N을 네 번 사용한 경우의 수를 구해보자. N을 네 번 사용하여 수를 표현하는 경우의 수 = { N을 세 번 사용한 경우의 수 }{ +, -, *, / }{ N } ∪ { N을 두 번 사용한 경우의 수 }{ +, -, *, / }{ N을 두 번 사용한 경우의 수 } ∪ { N을 세 번 사용한 경우의 수 }{ +, -, *, / }{ N }N을 count만큼 사용한다면 피연산자들의 자리를 바꾸며 모든 결과를 확인해야 한다. { N을 count - 1회 사용한 경우의 수 }{ +, -, *, / }{ N을 1회 사용한 경우의 수 } ∪ { N을 count - 2회 사용한 경우의 수 }{ +, -, *, / }{ N을 2회 사용한 경우의 수 } ∪ … { N을 count - 2회 사용한 경우의 수 }{ +, -, *, / }{ N을 2회 사용한 경우의 수 } ∪ { N을 1회 사용한 경우의 수 }{ +, -, *, / }{ N을 count - 1회 사용한 경우의 수 }N을 네 번 사용한 경우의 수가 많아 글이 너무 길어져서 접어둔다. 1️⃣ N을 세 번 사용한 경우의 수(중복 및 Inf 제거)는 [15, 5, 30, 6, 60, -5, 20, -4, 50, -20, 4, -50, 0, 125, 2, 11, 555]로 16가지다.아래는 세 번 사용한 경우의 수와 N의 사칙연산을 나열한 표다.사칙연산 별로 첫 번째 행은 { N을 세 번 사용한 경우의 수 } {+, -, \\*, / }{ N }, 두 번째 행은 { N을 세 번 사용한 경우의 수 }{ +, -, \\*, / }{ N }의 결과에 해당한다. &nbsp; 15 5 30 6 60 -5 20 -4 50 -20 4 -50 0 125 2 11 555 + 15 + 5 = 20 5 + 5 = 10 30 + 5 = 35 6 + 5 = 11 60 + 5 = 65 -5 + 5 = 0 20 + 5 = 25 -4 + 5 = 1 50 + 5 = 55 -20 + 5 = -15 4 + 5 = 9 -50 + 5 = -45 0 + 5 = 5 125 + 5 = 130 2 + 5 = 7 11 + 5 = 16 555 + 5 = 560 5 + 15 = 20 5 + 5= 10 5 + 30 = 35 5 + 6 = 11 5 + 60 = 65 5 + -5 = 0 5 + 20 = 25 5 + -4 = 1 5 + 50 = 55 5 + -20 = -15 5 + 4 = 9 5 + -50 = -45 5 + 0 = 5 5 + 125 = 130 5 + 2 = 7 5 + 11 = 16 5 + 555 = 560 - 15 - 5 = 10 5 - 5 = 0 30 - 5 = 25 6 - 5 = 1 60 - 5 = 55 -5 - 5 = -10 20 - 5 = 15 -4 - 5 = -9 50 - 5 = 45 -20 - 5 = -25 4 - 5 = -1 -50 - 5 = -55 0 - 5 = -5 125 - 5 = 120 2 - 5 = -3 11 - 5 = 6 555 - 5 = 550 5 - 15 = -10 5 - 5= 0 5 - 30 = -25 5 - 6 = -1 5 - 60 = -55 5 - -5 = 10 5 - 20 = -15 5 - -4 = 9 5 - 50 = -45 5 - -20 = 25 5 - 4 = 1 5 - -50 = 55 5 - 0 = 5 5 - 125 = -120 5 - 2 = 3 5 - 11 = -6 5 - 550 = -545 * 15 * 5 = 75 5 * 5 = 25 30 * 5 = 150 6 * 5 = 30 60 * 5 = 120 -5 * 5 = -25 20 * 5 = 100 -4 * 5 = -20 50 * 5 = 250 -20 * 5 = -100 4 * 5 = 20 -50 * 5 = -250 0 * 5 = 0 125 * 5 = 625 2 * 5 = 10 11 * 5 = 55 555 * 5 = 2,775 5 * 15 = 75 5 * 5 = 25 5 * 30 = 150 5 * 6 = 30 5 * 60 = 120 5 * -5 = -25 5 * 20 = 100 5 * -4 = -20 5 * 50 = 250 5 * -20 = -100 5 * 4 = 20 5 * -50 = -250 5 * 0 = 0 5 * 125 = 625 5 * 2 = 10 5 * 11 = 55 5 * 555 = 2,775 / 15 / 5 = 3 5 / 5 = 1 30 / 5 = 6 6 / 5 = 1 60 / 5 = 12 -5 / 5 = -1 20 / 5 = 4 -4 / 5 = -1 50 / 5 = 10 -20 / 5 = -4 4 / 5 = 0 -50 / 5 = -10 0 / 5 = 0 125 / 5 = 25 2 / 5 = 0 11 / 5 = 2 555 / 5 = 111 5 / 15 = 0 5 / 5= 1 5 / 30 = 1 5 / 6 = 1 5 / 60 = 0 5 / -5 = -1 5 / 20 = 0 5 / -4 = -2 5 / 50 = 0 5 / -20 = 0 5 / 4 = -1 5 / -50 = -1 5 / 0 = Inf 5 / 125 = 0 5 / 2 = 2 5 / 11 = 0 5 / 550 = 0 2️⃣ N을 두 번 사용한 경우의 수(중복 및 Inf 제거)는 [10, 0, 25, 1, 55]로 5가지다. &nbsp; 10 0 25 1 55 10 + 10 + 10 = 20 0 + 10 = 10 25 + 10 = 35 1 + 10 = 11 55 + 10 = 65 10 + 10 = 20 10 + 0 = 10 10 + 25 = 10 10 + 1 = 11 10 + 55 = 65 - 10 - 10 = 0 0 - 10 = -10 25 - 10 = 15 1 - 10 = -9 55 - 10 = 45 10 - 10 = 0 10 - 0 = 10 10 - 25 = -15 10 - 1 = 9 10 - 55 = -45 * 10 * 10 = 100 0 * 10 = 10 25 + 10 = 35 1 + 10 = 11 55 + 10 = 65 10 * 10 = 100 10 * 0 = 0 10 * 25 = 250 10 * 1 = 10 10 * 55 = 550 / 10 / 10 = 100 0 / 10 = 0 25 / 10 = 2 1 / 10 = 0 55 / 10 = 5 10 / 10 = 1 10 / 0 = Inf 10 / 25 = 0 10 / 1 = 10 10 / 55 = 0 0 + 10 + 0 = 10 0 + 0 = 0 25 + 0 = 25 1 + 0 = 1 55 + 0 = 55 0 + 10 = 10 0 + 0 = 0 0 + 25 = 25 0 + 1 = 1 0 + 55 = 55 - 10 - 0 = 10 0 - 0 = 0 25 - 0 = 25 1 - 0 = 1 55 - 0 = 55 0 - 10 = -10 0 - 0 = 0 0 - 25 = -25 0 - 1 = -1 0 - 55 = -55 * 10 * 0 = 0 0 * 0 = 0 25 * 0 = 0 1 * 0 = 0 55 * 0 = 0 0 * 10 = 0 0 * 0 = 0 0 * 25 = 0 0 * 1 = 0 0 * 55 = 0 / 10 / 0 = Inf 0 / 0 = NaN 25 / 0 = Inf 1 / 0 = Inf 55 / 0 = Inf 0 / 10 = 0 0 / 0 = NaN 0 / 25 = 0 0 / 1 = 0 0 / 55 = 0 25 + 10 + 25 = 35 0 + 25 = 25 25 + 25 = 50 1 + 25 = 26 55 + 25 = 80 25 + 10 = 35 25 + 0 = 25 25 + 25 = 50 25 + 1 = 26 25 + 55 = 80 - 10 - 25 = -15 0 - 25 = -25 25 - 25 = 0 1 - 25 = -24 55 - 25 = 30 25 - 10 = 15 25 - 0 = 25 25 - 25 = 0 25 - 1 = 24 25 - 55 = -30 * 10 * 25 = 250 0 * 25 = 0 25 * 25 = 625 1 * 25 = 25 55 * 25 = 1,375 25 * 10 = 250 25 * 0 = 0 25 * 25 = 625 25 * 1 = 1 25 * 55 = 1,375 / 10 / 25 = 0 0 / 25 = 0 25 / 25 = 1 1 / 25 = 0 55 / 25 = 2 25 * 10 = 250 25 * 0 = 0 25 * 25 = 625 25 * 1 = 1 25 * 55 = 1,375 1 + 10 + 1 = 11 0 + 1 = 1 25 + 1 = 26 1 + 1 = 2 55 + 1 = 56 1 + 10 = 11 1 + 0 = 1 1 + 25 = 26 1 + 1 = 2 1 + 55 = 56 - 10 - 1 = 11 0 - 1 = 1 25 - 1 = 26 1 - 1 = 2 55 - 1 = 56 1 - 10 = -9 1 - 0 = 1 1 - 25 = -24 1 - 1 = 0 1 - 55 = -54 * 10 * 1 = 10 0 * 1 = 0 25 * 1 = 25 1 * 1 = 1 55 * 1 = 55 1 * 10 = 10 1 * 0 = 0 1 * 25 = 25 1 * 1 = 1 1 * 55 = 55 / 10 / 1 = 10 0 / 1 = 0 25 / 1 = 25 1 / 1 = 1 55 / 1 = 55 1 / 10 = 0 1 / 0 = Inf 1 / 25 = 0 1 / 1 = 1 1 / 55 = 0 55 + 10 + 55 = 65 0 + 55 = 55 25 + 55 = 80 1 + 55 = 56 55 + 55 = 110 55 + 10 = 65 55 + 0 = 55 55 + 25 = 80 55 + 1 = 56 55 + 55 = 110 - 10 - 55 = -45 0 - 55 = -55 25 - 55 = -30 1 - 55 = -54 55 - 55 = 0 55 - 10 = 45 55 - 0 = 55 55 - 25 = 30 55 - 1 = 54 55 - 55 = 0 * 10 * 55 = 550 0 * 55 = 0 25 * 55 = 1,375 1 * 55 = 55 55 * 55 = 3,025 55 * 10 = 550 55 * 0 = 0 55 * 25 = 1,375 55 * 1 = 55 55 * 55 = 3,025 / 10 / 55 = 0 0 / 55 = 0 25 / 55 = 0 1 / 55 = 0 55 / 55 = 1 55 / 10 = 5 55 / 0 = Inf 55 / 25 = 2 55 / 1 = 55 55 / 55 = 1 이렇게 N의 사용 횟수를 1씩 가산하면서 number를 찾아야 한다. 문자열로 이어붙인 값까지 계산해야 하는 것도 잊지말자. 1️⃣의 경우의 수 중 60 / 5 = 12라는 연산이 존재한다. 즉, 5를 네 번 사용하면 12를 얻을 수 있고 가장 적게 사용한 횟수다.1️⃣ 특정 횟수를 사용했을 때의 경우의 수를 저장할 배열을 선언한다. 이 배열의 각 요소는 Set으로 초기화한다.중요한 것은 경우의 수 중에 number가 있는지 없는지다. number를 반환하는 연산식의 갯수는 중요하지 않으므로 결과값의 중복을 제거한다. 그러면 다음 횟수의 사칙연산에서 연산 횟수를 줄일 수 있다.1 ~ 8회만 계산하면 되므로 배열의 크기는 9로 고정한다. i번 사용한 연산의 결과는 arr[i]의 Set에 저장한다.1번 사용한 결과는 자기 자신뿐이므로 N을 arr[1]에 할당한다.const MAX_COUNT = 9;const arr = Array.from({ length: MAX_COUNT }, () =&gt; new Set());arr[1].add(N);1️⃣ 2 ~ 8회까지 반복하면서 (1)수학적으로 계산하기와 (2)문자로 인식 후 이어붙이기로 경우의 수를 구한다.//(2)문자로 인식 후 이어붙이기arr[count].add(+N.toString().repeat(count));//(1)수학적으로 계산하기//start는 몇 번 사용했는지를 체크하는 인덱스 변수다.//start가 1일 때 arr[1]와 arr[count - 1]의 사칙연산을 arr[count]에 저장한다.//start가 2일 때 arr[2]와 arr[count - 2]의 사칙연산을 arr[count]에 저장한다.let start = 1;while (start &lt; count) { arr[start].forEach((item) =&gt; { arr[count - start].forEach((item2) =&gt; { arr[count].add(item + item2); arr[count].add(item - item2); arr[count].add(item * item2); arr[count].add(Math.floor(item / item2)); }); }); //N을 count만큼 사용해서 얻은 경우의 수에 number가 존재하면 종료한다. if (arr[count].has(number)) return count; start++;}🏹 코드const solution = (N, number) =&gt; { if (N === number) return 1; const MAX_COUNT = 9; const arr = Array.from({ length: MAX_COUNT }, () =&gt; new Set()); arr[1].add(N); let count = 2; while (count &lt; MAX_COUNT) { let start = 1; arr[count].add(+N.toString().repeat(count)); while (start &lt; count) { arr[start].forEach((item) =&gt; { arr[count - start].forEach((item2) =&gt; { arr[count].add(item + item2); arr[count].add(item - item2); arr[count].add(item * item2); arr[count].add(Math.floor(item / item2)); }); }); if (arr[count].has(number)) return count; start++; } count++; } return -1;};👩‍🌾 새로 알게 되었거나 중요한 포인트해당 문제는 동적계획법(DP : Dynamic Programming) 유형의 문제다. 동적계획법은 큰 문제를 작은 문제로 나누어서 푸는 방식의 알고리즘이다. 이 문제에서 작은 문제는 특정 count개의 N으로 만들 수 있는 경우의 수를 배열에 저장(memoization)하는 것이고 이 배열의 요소를 또 다른 count개의 경우의 수를 구하는 데에 사용하여 최종 결과 값인 number를 구하는 것이다.나한테 이 문제가 꽤 어려워 문제를 해결하고 내용을 정리하는데 3일이 걸렸다… 많은 블로그를 참고했다. 🐝 참고 [프로그래머스] N으로 표현 (DP, 동적계획법) / C++ 동적 계획법(Dynamic Programming) 구르미의 개발 이야기 - 프로그래머스 문제 풀이 N으로 표현 작은 한걸음 - [프로그래머스] N으로 표현 Java 풀이" }, { "title": "📸 2022-12-12", "url": "/posts/221212TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트", "date": "2022-12-12 15:15:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 N으로 표현 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?버킷플레이스[오늘의 집] 코딩테스트 후기2022 Dev-Matching: 웹 프론트엔드 개발자(하반기)-2를 통과하여 얻게 된 기회였다. 서류 합격 메일과 함께 내가 원하는 날짜에 테스트를 응시할 수 있는 점이 좋았다.3시간동안 세 문제가 주어졌다. 한 문제를 온전히 해결하는 것이 중요하다는 안내문을 생각하며 하나라도 클린하고 싶었는데 전부 부분 점수만 획득했다.처음 겪은 연산법과 해결하지 못한 런타임 에러.. 시간초과… 그냥 실패…늘 그랬지만 이번 테스트도 해결 방법이 너무 궁금하다…" }, { "title": "📸 2022-12-03", "url": "/posts/221203TIL/", "categories": "TIL", "tags": "블로그설정, 자바스크립트, 코딩테스트", "date": "2022-12-03 22:55:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 2022 KAKAO TECH INTERNSHIP 코딩 테스트 공부 푸는중 카카오 테크 블로그에 올라온 해설과 다른 개발자들의 코드를 보는데도 이해가 가지 않는다… 다시 해보자! giscus 기능 추가 및 구글 애널리틱스 연계 그동안 블로그를 검색에 노출시키지 않고 사용했는데 이번에 해보고 싶어서 [Github Blog] 검색창 노출시키기를 참고해서 등록했다. 아직 승인?나지 않은 상태이지만 하는김에 gitHub 계정으로 댓글을 쓰는 giscus와 블로그 접속 통계를 확인하기 위해서 구글 애널리틱스를 연동했다. 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?❤️‍🔥 중요한건 꺾이지 않는 마음이번 월드컵에서 우리나라가 16강에 진출했다. 강한 상대인 포르투갈을 이기는 경기를 우리에게 선물해줬다. 선수들은 끝날 때까지 끝난게 아니라는걸 보여줬다. 올해를 마무리하며 나를 되돌아보는 요즘 와닿는 메세지다. 1%의 희망이 있다면 포기하지 말자. 나도 나를 못믿으면 누가 나를 믿겠어?" }, { "title": "📸 2022-11-16", "url": "/posts/221116TIL/", "categories": "TIL", "tags": "자바스크립트, 코딩테스트, 위크맵", "date": "2022-11-16 23:49:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 롤케이크 자르기 - Javascript 프로그래머스 행렬의 덧셈 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 자바스크립트 객체는 {키:값} 형태로 구성된다. 키는 고유한 값으로 중복되지 않는다. 같은 특징을 가지는 맵과 차이점은 맵은 객체와 달리 넣은 순서가 기억되고, 키가 문자열이 아니어도 된다는 것이다. 자바스크립트의 위크맵과 위크셋 맵과 위크맵의 첫 번째 차이는 key의 데이터 유형이다. 위크맵은 원시값을 key로 가질 수 없고 반드시 객체여야 한다. 위크맵의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 객체는 메모리와 위크맵에서 자동으로 삭제된다. 위크맵을 사용하는 이유 위크맵의 키로 설정한 객체에 대한 참조가 위크맵을 제외하고 존재하지 않는다면, 해당 객체는 가비지로 수거된다. 대체적으로 메모리 누수가 자주 일어날만한 코드에 사용한다. 🐝 참고 위크맵과 위크셋 - 모던 JavaScript 튜토리얼 ES2015(ES6) Map, Set, WeakMap, WeakSet - ZeroCho Blog WeakMap이 알고 싶다 🌟 내일은 어떻게 해보고 싶으세요? 프로그래머스 2022 KAKAO TECH INTERNSHIP 코딩 테스트 공부 해결하기 (오늘 시도했다가 해결 못함)" }, { "title": "프로그래머스 롤케이크 자르기 - 자바스크립트", "url": "/posts/programmers-132265/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-11-16 16:50:03 +0900", "snippet": "📄 문제프로그래머스 롤케이크 자르기구현해야 하는 것은롤케이크를 두 조각으로 나뉘게 잘랐을 때, 각 조각에 올려진 토핑 종류의 개수가 같아야 한다.예를 들어 아래 그림과 같이 롤케이크에 토핑이 올려져 있다고 가정해보자. 이미지 출처 : https://www.ssg.com/item/itemView.ssg?itemId=1000518951902&amp;siteNo=6001&amp;salestrNo=6005&amp;ckwhere=ssg_daum&amp;appPopYn=n&amp;utm_medium=PCS&amp;utm_source=daum&amp;utm_campaign=daum_pcs왼쪽에서부터 순서대로 토핑을 배열에 담으면 [🍓, 🥝, 🍑, 🍓, 🍓, 🥝, 🍑, 🍒]다. 그리고 4번째와 5번째 사이를 자른다.그럼 롤케이크는 [🍓, 🥝, 🍑, 🍓]가 있는 조각과 [🍓, 🥝, 🍑, 🍒]가 있는 조각으로 나뉘게 된다. 왼쪽 조각의 토핑 갯수는 4개다. 하지만 토핑 종류는 3개다(🍓가 두 번 들어있음). 오른쪽 조각도 토핑 갯수는 4개이지만 토핑 종류는 모두 다르므로 4개다. 결국 왼쪽 조각은 3개의 토핑을 맛볼 수 있고, 오른쪽 조각은 4개의 토핑을 맛볼 수 있으므로 공평하게 나눈 것이 아니다. 이미지 출처 : https://www.ssg.com/item/itemView.ssg?itemId=1000518951902&amp;siteNo=6001&amp;salestrNo=6005&amp;ckwhere=ssg_daum&amp;appPopYn=n&amp;utm_medium=PCS&amp;utm_source=daum&amp;utm_campaign=daum_pcs이번엔 토핑이 [🍓, 🥝, 🍓, 🍓, 🥝, 🍓, 🍓, 🍓]로 들어있고, 두 번째와 세 번째 사이를 자른다. 먹을 수 있는 토핑의 총 갯수는 왼쪽 조각에 2개, 오른쪽 조각에 6개이지만 토핑 종류는 🍓, 🥝로 양쪽 다 2개다. 이 경우는 공평하게 나눈 것이다.결국 몇 개의 토핑을 먹느냐보다 몇 가지의 토핑을 먹느냐가 중요한 것이다. 총량은 중요하지 않고 가짓수를 구해야 하므로 조각을 나눠서 토핑의 중복을 없앤 후 양쪽의 갯수가 일치하는지 확인해야 한다.😫 실패한 사례를 먼저 보자.특정 토핑이 어느 조각에 올라가 있는지에 대해 모든 경우를 고려해야 하므로 topping 배열을 순회하는 작업이 필요하다.전체 토핑 값이 담겨있는 배열(A)의 요소를 하나씩 제거해서 다른 배열(B)로 삽입하고, A와 B의 중복을 없앤 요소의 갯수를 비교해서 일치하면 방법의 수를 누적시키려고 했다.A의 마지막 요소를 제거(pop())하여 B에 삽입(push())하기로 했다. 그 후 Set으로 중복을 제거하고 각각 Set의 길이를 비교했다. 코드는 다음과 같다.const solution = (topping) =&gt; { const temp = []; let result = 0; let tempCnt, toppingCnt; while (topping.length &gt; 0) { temp.push(topping.pop()); tempCnt = new Set(temp).size; toppingCnt = new Set(topping).size; if (tempCnt === toppingCnt) result++; } return result;};시간 초과가 발생했다. 시간 복잡도를 계산해보면 while문으로 전체 배열을 순회하기 위해 O(n), 부분 배열을 Set으로 변경하기 위해 또 순회하므로 O(n)으로 총 O(n2)이 된다.제한사항이 1 ≤ topping의 길이 ≤ 1,000,000이므로 길이가 긴 배열이 들어왔을 때는 시간 초과가 발생한다. 그러므로 중첩 반복을 피해서 부분 배열의 요소 갯수를 구하는 방법을 생각해야 한다.그래서 반복을 두 번하긴 하되, 중첩없이 각각 순회하면서 원하는 값을 얻어내기로 했다.1️⃣ 먼저 전체 배열을 순회하면서 토핑 종류의 갯수를 파악했다.Map 객체의 키 값은 고유하다. 즉, 키 값은 중복되지 않는다. 토핑 현황을 관리하기 위해서 토핑을 key로, 토핑 갯수를 value로 하는 요소를 갖는 Map을 선언한다.위에서 언급한 [🍓, 🥝, 🍑, 🍓, 🍓, 🥝, 🍑, 🍒]의 토핑 종류를 Map에 저장하면 {🍓 =&gt; 3, 🥝 =&gt; 2, 🍑 =&gt; 2, 🍒 =&gt; 1} 가 된다.const solution = (topping) =&gt; { const map1 = new Map(); topping.forEach((t) =&gt; { map1.set(t, (map1.get(t) || 0) + 1); });};이제 map1에는 롤케이크의 토핑의 종류와 갯수가 들어있다.2️⃣ 롤케이크를 자르며 생긴 나머지 조각의 토핑 종류의 갯수를 저장하고, 원래 조각에서의 해당 토핑의 갯수를 갱신해야 한다.롤케이크 전체에서 토핑을 하나씩 제거할 것이므로 특정 토핑이 제거될 때 1️⃣에서 만든 Map에서 해당 토핑의 갯수를 제거하고, 제거한 토핑이 담긴 새로운 조각의 토핑 현항을 관리하는 새로운 Map에 추가한다.원래 전체 조각을 A, 새로 자른 조각을 B라고 하자.전체 조각 A는 [🍓, 🥝, 🍑, 🍓, 🍓, 🥝, 🍑, 🍒]이다. A조각의 토핑 종류와 갯수 현황을 Map에 담으면 {🍓 =&gt; 3, 🥝 =&gt; 2, 🍑 =&gt; 2, 🍒 =&gt; 1}이다. 여기서 가장 마지막 토핑 앞에서 자른다면 전체 조각에서 🍒가 없어지는 것이다. 그러므로 토핑 갯수는 {🍓 =&gt; 3, 🥝 =&gt; 2, 🍑 =&gt; 2, 🍒 =&gt; 0}이 된다.그리고 칼로 자르면서 새로 생긴 조각 B는 [🍒]이다. B의 토핑 현황은 {🍒 =&gt; 1}이다.A에 있던 토핑이 B로 이동한 것이므로 A의 토핑을 관리하는 Map에서는 🍒의 토핑 갯수를 1 감소시키고, B의 토핑을 관리하는 Map에는 🍒의 토핑 갯수를 1 증가시킨 것이다. 그리고 A는 🍒가 하나도 없기 때문에 A 조각의 토핑을 관리하는 Map에서 🍒를 key로 갖는 요소를 delete를 해준다.그러면 A는 3개의 토핑(🍓, 🥝, 🍑), B는 1개의 토핑(🍒)을 맛볼 수 있으므로 공평하지 않다. 이 작업을 A에 있는 토핑이 B로 모두 넘어올 때까지 수행해야 한다.[🍓, 🥝, 🍑, 🍓, 🍓], [🥝, 🍑, 🍒]으로 자른다면 토핑 현황은 A는 {🍓 =&gt; 3, 🥝 =&gt; 1, 🍑 =&gt; 1}, B는 {🥝 =&gt; 1, 🍑 =&gt; 1, 🍒 =&gt; 1}이 된다. 양쪽 모두 3개의 토핑을 맛볼 수 있으므로 공평한 것이다.const solution = (topping) =&gt; { const map2 = new Map(); // ... topping.forEach((t) =&gt; { //map1에 있는 토핑을 하나씩 가져온다. 그러므로 map2는 1씩 증가하고, map1은 1씩 감소한다. map2.set(t, map2.get((t || 0) + 1)); map1.set(t, map1.get(t) - 1); // value가 0인 것은 해당 조각에 토핑이 하나도 존재하지 않는 것이므로 제거한다. if (map1.get(t) === 0) map1.delete(t); // size가 같은 것은 중복을 제거한 토핑 종류의 갯수가 일치하는 것이므로 공평한 방법의 수를 1 증가시킨다. if (map1.size === map2.size) result++; });};🏹 코드const solution = (topping) =&gt; { let result = 0; const map1 = new Map(); const map2 = new Map(); topping.forEach((t) =&gt; { map1.set(t, (map1.get(t) || 0) + 1); }); topping.forEach((t) =&gt; { map2.set(t, map2.get((t || 0) + 1)); map1.set(t, map1.get(t) - 1); if (map1.get(t) === 0) map1.delete(t); if (map1.size === map2.size) result++; }); return result;};👩‍🌾 새로 알게 되었거나 중요한 포인트최대한 쉽게 설명하려다 보니 글이 굉장히 길어졌지만 배열의 순회하며 값을 얻어야 할 때 어떻게 하면 시간 복잡도를 줄일 수 있을까를 고민해봐야 하는 문제다. ~(이모지를 이용하면 쉽게 풀어낼줄 알았는데 너무 많이 써버려서 가독성이 떨어진다…)~이전에 배열의 중복을 제거하기 위한 방법으로 Set을 사용했던 것을 떠올려 이번에도 Set을 사용하려고 했지만 시간 초과가 발생했다.실패한 사례와 통과한 사례의 코드를 살펴보면 둘 다 2번의 반복을 통해 토핑을 한쪽에서 다른쪽으로 하나씩 옮겨가며 결과를 얻어내지만 실패 사례는 중첩 반복으로 O(n) * O(n) = O(n2)이 되고, 성공 사례는 반복을 연달아서 두 번하며 O(n) + O(n) = O(n)이 된다.제한 사항에 배열의 길이가 큰 경우에는 중첩이나 시간 복잡도가 큰 메서드의 사용을 지양해서 시간 복잡도를 줄여서 해결하도록 하자." }, { "title": "📸 2022-11-13", "url": "/posts/221113TIL/", "categories": "TIL", "tags": "자바스크립트, 과제테스트", "date": "2022-11-13 23:23:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 2022 Dev-Matching: 웹 프론트엔드 개발자(하반기)-2🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 부트스트랩의 .table-striped처럼 짝/홀수 마다 스타일을 적용하고 싶을 때가 있다. 그럴 때는 아래와 같이 사용하자! /* 짝수 요소에만 적용 */엘리먼트명:nth-child(even) { background-color: yellow;}/* 홀수 요소에만 적용 */엘리먼트명:nth-child(odd) { background-color: green;} 또는 /* 짝수 요소에만 적용 */엘리먼트명:nth-child(2n) { background-color: yellow;}/* 홀수 요소에만 적용 */엘리먼트명:nth-child(2n + 1) { background-color: green;} 🌟 내일은 어떻게 해보고 싶으세요? 휴식2022 Dev-Matching: 웹 프론트엔드 개발자(하반기)-2 후기데브 매칭이 올해 상반기, 그리고 하반기-1에 이어서 하반기-2를 했다. (하반기-1을 접수 기간을 잘못 알아서 신청을 못했었다는..)이번엔 4시간동안 1문제를 해결해야 했다. 프로그래머스는 이전 과제 테스트를 연습할 수 있게 제공해주기 때문에 며칠동안 과제테스트들만 공략했다.하반기-1의 경우 스타일 작업이 꽤 많았고, 무한 스크롤 등 다소 난이도가 높은 요구사항이 있었는데 그에 비해 하반기-2는 수월했다. 내 기준 올해 데브 매칭 중 가장 난이도가 낮았다.늘 긴장하며 코드 먼저 작성하려고 했었는데 이번에는 시작하고 20분 동안 빈 종이에 요구사항을 정리하고 모듈 구조와 각 컴포넌트가 관리할 상태 등을 설계하고 작업을 시작하였다. 이게 복잡하지 않아서 그랬을 수도 있지만, 꽤 뿌듯했다.시간이 꽤 많이 남아서 처음 설계보다 조금 더 좋은 코드로 변경하기도 했지만 그래도 조금 더 생산적인 코드를 짤 수도 있었을텐데 하는 아쉬움은 조금 남는다." }, { "title": "📸 2022-11-11", "url": "/posts/221111TIL/", "categories": "TIL", "tags": "자바스크립트, 과제테스트", "date": "2022-11-11 23:27:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 인사 정보 SPA 리뉴얼 - Javascript 다시 풀어보기 바닐라 자바스크립트로 상태관리 구현하기 정말 설명을 잘해둔 블로그를 찾았다…! ⭐️ 🐝 참고 Vanilla Javascript로 웹 컴포넌트 만들기 Vanilla Javascript로 상태관리 시스템 만들기 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 프로그래머스 인사 정보 SPA 리뉴얼 과제 테스트 다시 풀어보기(이틀 연속 풀었지만 완벽히 구현하지 못함..😫) 그 외 프로그래머스에서 제공하는 과제 테스트 풀어보기" }, { "title": "📸 2022-11-10", "url": "/posts/221110TIL/", "categories": "TIL", "tags": "자바스크립트, 과제테스트", "date": "2022-11-10 23:09:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 인사 정보 SPA 리뉴얼 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 자바스크립트만으로 SPA를 구현하기 위해서 History API에 대한 이해가 필요하다. KimKwon님의 frontend-basic gitHub 저장소 : History API 직접 이벤트를 만들 수 있는 Web API CustomEvent를 사용하면 된다. Event와 CustomEvent의 차이점은 CustomEvent의 두 번째 인수엔 객체가 들어갈 수 있는데, 이 객체에 detail이라는 프로퍼티를 추가해 커스텀 이벤트 관련 정보를 명시하고, 정보를 이벤트에 전달할 수 있다. const newEvent = new CustomEvent(\"hello\", { detail: { name: \"예은\" } });// 이벤트 객체를 생성한 다음엔 dispatchEvent(event)를 호출해 요소에 있는 이벤트를 반드시 '실행’시켜줘야 합니다// (dispatch는 일을 '처리하다’라는 뜻을 가진 영어단어입니다 – 옮긴이).// 이렇게 이벤트를 실행시켜줘야 핸들러가 일반 브라우저 이벤트처럼 이벤트에 반응할 수 있습니다.newEvent.dispatchEvent(newEvent); 🐝 참고 커스텀 이벤트 디스패치 - 모던 JavaScript 튜토리얼 바닐라 자바스크립트로 무한 스크롤 구현하기 아래 참고한 포스트는 모두 Intersection Observer API를 이용해 무한 스크롤을 구현한다. 미세한 차이는 관찰 대상을 무엇으로 지정하느냐다. (1️⃣ 현재 화면에서 보이는 목록 요소의 가장 마지막 요소를 관찰)할 것인지 혹은 (2️⃣ 목록 요소 하단에 관찰을 위한 대상을 미리 정의)할 것인지다. 1️⃣ 현재 화면에서 보이는 목록 요소의 가장 마지막 요소를 관찰하는 경우는 ul의 last-child를 관찰하다가 만약 뷰포트 내로 들어온다면 새로운 요소 append한다. 그러면 맨 마지막으로 새 요소가 들어오면서 last-child가 갱신된다. 즉, 원래 관찰하던 last-child는 더 이상 마지막 요소가 아니므로 관찰을 중지하고 새로운 last-child를 관찰 대상으로 설정하고 다시 마지막 요소가 루트 요소로 들어오면 새 요소를 만들어서 관찰 대상을 갱신하는 것을 반복한다. 2️⃣ 목록 요소 하단에 관찰을 위한 대상을 미리 정의하려면 ul 태그 바로 다음에 임의의 요소를 생성하고 이 요소가 루트 요소 내로 들어오는지 계속 관찰한다. ul의 last-child가 루트 요소 내로 들어오게 되면 바로 아래에 위치한 관찰 대상도 들어오게 되므로 목록이 갱신된다. 🐝 참고 바닐라 JS로 무한스크롤 구현을 위한 베이직 공부 실무에서 느낀 점을 곁들인 Intersection Observer API 정리 🌟 내일은 어떻게 해보고 싶으세요? 프로그래머스 인사 정보 SPA 리뉴얼 과제 테스트 다시 풀어보기 그 외 프로그래머스에서 제공하는 과제 테스트 풀어보기" }, { "title": "📸 2022-11-07", "url": "/posts/221107TIL/", "categories": "TIL", "tags": "자바스크립트, 객체, ES6, 프로토타입, 코딩테스트", "date": "2022-11-07 23:04:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 객체의 프로토타입 정리하기 프로그래머스 2022 KAKAO TECH INTERNSHIP 두 큐 합 같게 만들기 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 계산된 프로퍼티(computed property)라는 ES6 기능을 사용하면 대괄호를 객체 리터럴 안에 넣을 수 있다. const PROPERTY_NAME = \"p1\";function computerPropertyName() { return \"p2\";}// 1️⃣ 변수에 저장되어 있거나 함수의 반환 값일 때에는 객체를 먼저 만들고 대괄호로 프로퍼티를 추가하는 과정이 필요하다.let o = {};o[PROPERTY_NAME] = 1;o[computerPropertyName()] = 2;// 2️⃣ ES6의 계산된 프로퍼티 기능을 사용하면 객체 선언과 동시에 대괄호로 프로퍼티를 초기화할 수 있다.let o = { [PROPERTY_NAME] : 1; [computerPropertyName()] : 2; // 즉시실행함수를 사용하여 바로 평가하기 [(() =&gt; \"p3\")()] : 3;};console.log(o); // {p1: 1, p2: 2, p3: 3} 🌟 내일은 어떻게 해보고 싶으세요?" }, { "title": "🏄🏻‍♀️ [자바스크립트] 두 큐 합 같게 만들기", "url": "/posts/programmers-118667/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-11-07 19:15:00 +0900", "snippet": "📄 문제프로그래머스 2022 KAKAO TECH INTERNSHIP 두 큐 합 같게 만들기구현해야 하는 것은주어진 두 개의 배열에 있는 요소들의 합이 같아야 한다. 각 배열 요소의 총합이 같지 않으면, 배열 간 요소들을 이동하여 합을 일치시킨다.이 때, 이동 규칙은 다음과 같다. 본인 배열의 총합이 크다고 판단되어 요소를 제거하고 싶을 때는 본인 배열의 첫 번째 요소부터 제거해야 한다. 본인 배열의 총합이 작다고 판단되어 상대 배열의 요소를 추가하고 싶을 때는 상대 배열의 첫 번째 요소를 제거하고 그 값을 본인 배열의 마지막 요소로 삽입한다.단, 어떤 방법으로도 각 배열의 원소 합을 같게 만들 수 없는 경우도 존재한다.간단하게 생각하면 하나의 배열을 기준으로 상대 배열의 shift(배열의 첫 번째 요소를 제거한다.) 요소를 push(배열의 마지막 요소로 삽입한다.)하고 새로운 합을 구하기 위해 reduce(배열을 반복하며 사용자 정의 함수에 따라 값을 누적한다.)로 합을 구하면 된다. 하지만 shift와 reduce는 시간 복잡도가 큰 함수들이다. 따라서 이 문제에서 사용하면 시간초과가 발생한다.하나의 배열로 만든 후, (인덱스 변수로 시작점과 끝점을 수정하며 해당 영역에 포함된 요소들의 합)과 (그 외 요소들의 합)을 비교하면 된다. 각 영역의 총합이 같아지거나 배열의 끝까지 반복할 때까지 시작점 또는 끝점을 수정하며 영역별 합을 비교하며 최종 결과값인 작업 횟수를 누적한다.1️⃣ 파라미터로 전달된 두 배열을 하나로 합친다.구조 분해 할당 구문을 사용해서 두 배열을 합쳐 새로운 배열 totalQueue를 선언한다.그리고 totalQueue 요소들의 합의 절반 값을 구해야한다. 두 개의 배열 각자의 총합이 같아야 하므로 시작점과 끝점을 이용하여 지정한 영역 내 요소들의 합이 총합 / 2이 되는 영역을 찾을 것이기 때문이다.두 개의 배열 합은 같은 값을 가져야하기 때문에 총합 / 2의 값이 홀수라면 어떤 방법으로도 각자의 합을 같게 만들 수 없으므로 종료한다.const solution = (queue1, queue2) =&gt; { const totalQueue = [...queue1, ...queue2]; const halfOfSum = totalQueue.reduce((acc, cur) =&gt; acc + cur, 0) / 2; if (halfOfSum % 1 !== 0) return -1;};2️⃣ 시작점과 끝점을 초기화하고 배열을 순회하며 요소들의 합이 ‘총합 / 2’의 값인 영역을 찾는다.시작점 start는 배열의 시작 인덱스인 0으로 초기화한다. 끝점 end는 파라미터로 전달받았던 큐들의 길이로 초기화한다. 전달받을 당시의 2개의 큐는 길이가 같기 때문에 어느 한 쪽의 값을 할당해도 동일하다.그러면 처음 합을 구할 영역의 합을 구하고 이 값에 따라 영역의 기준점들을 수정해야 한다. start ~ end영역의 합이 총합 / 2가 같다면 한쪽 영역은 합이 같아지기 위한 조건을 만족시키므로 start ~ end영역 이 외의 나머지 요소들의 합을 구해야 한다. 나머지 요소들의 합이 start ~ end 영역의 합과 같다면 작업 횟수를 리턴한다. 나머지 요소들의 합이 start ~ end 영역의 합과 같지 않다면 각 배열의 합은 같게 만들 수 없음을 의미한다. 그러므로 -1을 리턴한다. start ~ end영역의 합이 총합 / 2보다 크면 값을 줄여야 한다. 그러므로 start를 1만큼 증가시킨다. 이는 이동 규칙 중 요소를 꺼낼 때에는 본인 배열의 첫 번째 요소를 선택해야 한다는 것을 만족한다. start ~ end영역의 합이 총합 / 2보다 작으면 값을 추가해야 한다. 그러므로 end를 1만큼 증가시킨다. 이는 이동 규칙 중 요소를 추가할 때에는 상대 배열의 첫 번째 요소를 선택해야 본인 배열의 마지막 요소로 삽입한다는 것을 만족한다.문제 설명에서 주어진 예시로 다시 정리해보자.queue1 = [3,2,7,2], queue2 = [4,6,5,1]로 길이가 4인 두 개의 큐가 주어진다. 따라서 start는 0으로, end는 4로 초기화한다.그리고 두 개의 큐를 합하여 [3,2,7,2,4,6,5,1]라는 새로운 배열을 생성한다. 배열의 총합은 30이며 그의 절반 값은 15이다. 즉, 요소의 합이 15가 되는 구간을 찾아야 한다.start와 end에 따라 처음 합을 구할 영역은 [3,2,7,2]다. 합은 14로 절반 값보다 작다. 그러므로 영역을 넓혀야 한다. 규칙에 따라 끝점에서 오른쪽으로 1만큼 이동한다.이제 start는 0, end는 5이다. end가 4임에도 totalQueue[3]까지만 영역을 지정하는 이유 배열의 일부분만 가져오기 위해 slice 함수를 사용한다. slice는 시작 인덱스부터 종료 인덱스 전까지만 반환하기 때문이다. (substring과 동일하다고 생각하자.) 즉, 배열의 slice 함수의 시작점과 끝점을 기준으로 start와 end를 설정하였다는 것을 명심하자.합을 구할 영역은 한 칸 늘어서 [3,2,7,2,4]다. 합은 18로 절반 값보다 크다. 그러므로 영역을 줄여야 한다. 규칙에 따라 시작점에서 왼쪽으로 1만큼 이동한다.이제 start는 1, end는 5이다.합을 구할 영역은 한 칸 줄어들어 [2,7,2,4]다. 합은 15로 절반 값보다 정확히 일치한다! 이제 해당 영역이 아닌 나머지 요소들의 합을 확인해야 한다.각 큐의 합이 같아지는 구간은 [2,7,2,4], [3,6,5,1]이다.두 번째 예제는 queue1 = [1,2,1,2], queue2 = [1,10,1,2]로 주어진다.위의 과정을 거치며 최종적으로 아래와 같이 영역이 분리된다.🏹 코드const solution = (queue1, queue2) =&gt; { const totalQueue = [...queue1, ...queue2]; const halfOfSum = totalQueue.reduce((acc, cur) =&gt; acc + cur, 0) / 2; if (halfOfSum % 1 !== 0) return -1; let start = 0, end = queue1.length; let result = 0; let sum = totalQueue.slice(start, end).reduce((acc, cur) =&gt; acc + cur, 0); while (end &lt;= totalQueue.length) { if (sum &lt; halfOfSum) { sum += totalQueue[end++]; result++; } else if (sum &gt; halfOfSum) { sum -= totalQueue[start++]; result++; } else { const a = totalQueue .splice(start, end - start) .reduce((acc, cur) =&gt; acc + cur, 0); const b = totalQueue.reduce((acc, cur) =&gt; acc + cur, 0); if (a === b) return result; else return -1; break; } } return -1;};" }, { "title": "🌈 재미있는 자바스크립트 세계 - 프로토타입", "url": "/posts/prototype-of-javascript/", "categories": "study", "tags": "자바스크립트, 객체, 프로토타입", "date": "2022-11-07 15:04:00 +0900", "snippet": " 📖 자바스크립트 완벽 가이드 책 읽으면서 정리하는 글🚧⚒️🔧🔨🚜🦺👷🏻 정리중…프로토타입자바스크립트 객체 거의 대부분은 자신과 연결된 두 번째 객체를 가진다. 여기서 두 번째 객체를 프로토타입이라 부른다. 즉, 자바스크립트 객체 거의 대부분은 프로토타입에서 프로퍼티를 상속 받는다." }, { "title": "📸 2022-11-05", "url": "/posts/221105TIL/", "categories": "TIL", "tags": "클린코드, 자바스크립트, 즉시실행함수", "date": "2022-11-05 23:44:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? [클린코드 자바스크립트] 분기 다루기 강의 ⚠️ 우선 Obsidian에 강의 내용 정리하기 [자바스크립트 완벽 가이드] 6장 객체 읽기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 자바스크립트에서 함수를 선언할 때는 function이라는 키워드로 시작한다. 따라서 자바스크립트는 유효한 statement에서 첫 단어가 function이라면, 함수 정의가 일어날 것이라고 예측한다. 아래와 같이 function 키워드 앞에 ”!”를 붙여주면 표현식으로 다루게 된다. 즉, 생기자마자 바로 호출되는 함수 표현식이 된 것이다. ”!” 외에도 “+”, “-“, ~ 등 다양한 방식으로 작성해도 같은 결과를 보인다. !(function () { alert(\"Hello from IIFE!\");})();// \"Hello from IIFE\" 메시지를 보여줍니다. 즉시실행함수는 정의되자마자 즉시 실행되는 함수를 말한다. 선언과 동시에 호출되고 반환되므로 재사용할 수 없다. 이름을 붙여 사용할 수 있지만 큰 의미는 없다. 🐝 참고 자바스크립트 개발자라면 알아야 할 33가지 개념 #8 자바스크립트 필수요소 : IIFE 마스터하기 JavaScript - 즉시실행함수(IIFE) 🌟 내일은 어떻게 해보고 싶으세요? 자바스크립트 완벽 가이드 책 계속 읽고 프로그래머스 코딩 테스트 풀기[자바스크립트 완벽 가이드] 6장 객체 🐝 책 정보 객체는 프로퍼티의 순서 없는 집합이며 각 프로퍼티에는 이름과 값이 있습니다. 자바스크립트 객체는 자신만의 프로퍼티를 가지는 것 외에도, ‘프로토타입’으로 불리는 다른 객체에서 프로퍼티를 상속하기도 합니다. 자바스크립트에서 문자열, 숫자, 심벌, true, false, null, undefined가 아닌 값은 전부 객체입니다. 객체를 생성하는 가장 쉬운 방법은 객체 리터럴입니다. 객체 리터럴의 가장 단순한 형태는 콜론으로 구분한 이름:값 쌍을 콤마로 구분해 중괄호로 감싼 형태입니다. 자바스크립트 객체 거의 대부분은 자신과 연결된 두 번째 객체를 갖습니다. 여기서 두 번째 객체를 프로토타입이라 부르며, 첫 번째 객체는 프로토타입에서 프로퍼티를 상속합니다." }, { "title": "📸 2022-11-04", "url": "/posts/221104TIL/", "categories": "TIL", "tags": "코딩테스트", "date": "2022-11-04 23:35:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 2022 KAKAO TECH INTERNSHIP 성격 유형 검사하기 - Javascript 프로그래머스 이중우선순위큐 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? Javascript SORT 함수에 대해 잘 정리된 블로그 발견! 🔖 Javascript Sort함수에 대한 잡지식 Javascript 배열 메서드의 시간 복잡도에 대해 잘 정리된 블로그 발견! 🔖 자바스크립트 Array 메소드 및 예제에 대한 시간 복잡도 Big O 커밋 취소하려고 git reset HEAD^ 때렸는데 로컬엔 파일이 돌아왔지만 왜 깃헙에는 커밋이 남아있을까..? 🌟 내일은 어떻게 해보고 싶으세요? 오늘 도서관에서 빌려온 자바스크립트 완벽 가이드 읽어보기" }, { "title": "🏄🏻‍♀️ [자바스크립트] 이중 우선순위 큐", "url": "/posts/programmers-42628/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-11-04 19:39:00 +0900", "snippet": "📄 문제프로그래머스 이중우선순위큐 ⚠️ 백준 - 골드 IV 이중 우선순위 큐와 동일한 문제다. 프로그래머스의 채점 환경은 비교적 느슨하기에(?) 배열의 sort 또는 shift, splice처럼 시간 복잡도가 높은 메서드를 반복해서 사용해도 해결된다.백준에서 우선순위 큐 클래스로 해결하였기에 여기선 배열의 메서드만을 활용해 문제를 해결하였다.구현해야 하는 것은명렁어에 따라 최댓값을 삭제하거나 최솟값을 삭제해야 한다. 하나의 배열에 데이터가 삽입될 때마다 오름차순으로 정렬해준다. 삭제 명령에 따라 최소값 삭제는 가장 첫 번째 요소를 제거하고, 최대값 삭제는 가장 마지막 요소를 제거한다.오름차순으로 정렬했기에 배열에 남은 최소값과 최대값은 각각 첫 번째와 마지막 요소를 반환하면 된다.🏹 코드const solution = (operations) =&gt; { const heap = []; operations.forEach((operation) =&gt; { const [command, num] = operation.split(\" \"); console.log(operation); if (command === \"I\") { heap.push(+num); heap.sort((a, b) =&gt; a - b); } else if (+num === 1) { heap.pop(); } else if (+num === -1) { heap.shift(); } }); return heap.length ? [Math.max(...heap), Math.min(...heap)] : [0, 0];};" }, { "title": "🏄🏻‍♀️ [자바스크립트] 성격 유형 검사하기", "url": "/posts/programmers-118666/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-11-04 15:56:00 +0900", "snippet": "📄 문제프로그래머스 2022 KAKAO TECH INTERNSHIP 성격 유형 검사하기구현해야 하는 것은주어진 지표와 선택지 목록을 순회하며 성격유형에 점수를 누적해야 한다. 모든 요소를 방문한 후에 대응되는 성격유형끼리 비교하여 더 높은 점수를 받은 성격유형을 판단한다.1️⃣ 질문을 순회하며 각 성격유형이 얻을 점수를 누적해야 한다.각 성격유형을 프로퍼티로 가진 객체를 선언하고 기본 값은 0으로 초기화한다.특정한 key값에 값을 누적하기 때문에 Map을 사용했는데 코드가 다소 길어졌다.만약 map 자체에 key값에 대응하는 값을 모두 초기화를 한다면 map.put(\"R\", 0)의 구문을 8번 반복해야하고, 초기화를 하지 않으면 해당 key와 대응하는 값이 map에 존재하는지 체크해야 하기 때문에 값을 삽입하는 구문에서 map.put(\"R\", map.get(\"R\") || 0 + score)과 같이 코드가 길어져 객체를 사용하는 방법으로 수정했다.const solution = (survey, choices) =&gt; { const result = { R: 0, T: 0, C: 0, F: 0, J: 0, M: 0, A: 0, N: 0 };};2️⃣ 질문을 순회하면서 특정 성격유형에 점수를 누적한다.문제 설명에 따르면 survey[i]의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미하고, survey[i]의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미한다.아래의 표는 survey[i](질문에 대한 선택지를 의미한다.)의 뜻과 각 성격 유형에 부여하는 점수를 나타낸다. choices 뜻 부여되는 점수 1 매우 비동의 3 2 비동의 2 3 약간 비동의 1 4 모르겠음 0 5 약간 동의 1 6 동의 2 7 매우 동의 3 1 ~ 3까지는 비동의 선택지, 5 ~ 7까지는 동의 선택지에 점수를 부여한다. 4는 어느 선택지에도 점수를 부여하지 않는다.그리고 부여할 점수의 값만 보았을 때, 1과 7은 3점을, 2와 6은 2점, 3, 5는 1점을 부여한다. 이는 choices[i] 값에서 4를 뺀 값의 절대값으로 부여할 점수를 쉽게 계산할 수 있다.예를 들어, survey[0]이 “AN”이며 choices[0]이 7이라면, choices[0]의 값이 5 ~ 7에 해당하므로 동의 선택지를 선택한 것이고, 판단 지표 중 N 유형에 3점(choices[0] - 4 = 3)을 부여하는 것이다.for (let i = 0; i &lt; survey.length; i++) { // 구조 분해 할당으로 질문에 대한 비동의 선택 지표와 동의 선택 지표를 추출한다. // 질문에 대한 선택이 비동의 관련이면 disAgree 유형에 점수를 부여하고, 동의 관련이면 agree 유형에 점수를 부여한다. const [disAgree, agree] = survey[i].split(\"\"); // 비동의 또는 동의 여부를 확인하기 위해 중간 값인 4보다 크면 동의, 작으면 비동의 유형으로 판단한다. // 부여할 점수는 절대값 함수인 Math.abs를 이용해서 계산한다. result[choices[i] &lt;= 4 ? disAgree : agree] += Math.abs(4 - choices[i]);}3️⃣ 모든 질문을 확인하였다면 대응되는 성격유형끼리 비교하여 더 높은 점수를 가진 유형을 반환한다.질문 목록을 순회하기 전에 대응되는 성격유형끼리 배열에 저장해둔다. 점수값을 비교할 때 같은 값을 가지면 사전 순으로 빠른 성격 유형을 검사자의 성격 유형이라고 판단하므로 사전 순으로 정렬해야한다. 예를 들어, “TR”이 아닌 “RT”라는 값을 사용해야 한다.const TYPES = [\"RT\", \"CF\", \"JM\", \"AN\"];/* ... 질문을 순회하며 성격유형에 점수를 부여한다 ... */return TYPES.map((type) =&gt; { const [c1, c2] = type.split(\"\"); // 더 높은 점수를 가진 유형을 반환하는데 사전 순으로 정렬해뒀기 때문에 따로 정렬할 필요없다. return result[c1] &lt; result[c2] ? c2 : c1;}).join(\"\");🏹 코드const solution = (survey, choices) =&gt; { const TYPES = [\"RT\", \"CF\", \"JM\", \"AN\"]; const result = { R: 0, T: 0, C: 0, F: 0, J: 0, M: 0, A: 0, N: 0 }; for (let i = 0; i &lt; survey.length; i++) { const [disAgree, agree] = survey[i].split(\"\"); const addScoreType = choices[i] &lt;= 4 ? disAgree : agree; result[choices[i] &lt;= 4 ? disAgree : agree] += Math.abs(4 - choices[i]); } return TYPES.map((type) =&gt; { const [c1, c2] = type.split(\"\"); return result[c1] &lt; result[c2] ? c2 : c1; }).join(\"\");};" }, { "title": "📸 2022-11-02", "url": "/posts/221102TIL/", "categories": "TIL", "tags": "코딩테스트", "date": "2022-11-02 23:05:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 디스크 컨트롤러 - Javascript [📖 리팩터링 2판] Chapter 02 읽기 드림코딩 리팩토링의 모든것 🚀 [2. 리팩터링 원칙] 강의 들으며 책에 밑줄 긋기✍️ 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 프로그래머스 이중우선순위큐 다시 풀어보기" }, { "title": "🏄🏻‍♀️ [자바스크립트] 디스크 컨트롤러", "url": "/posts/programmers-42627/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-11-02 16:32:00 +0900", "snippet": "📄 문제프로그래머스 디스크 컨트롤러구현해야 하는 것은파라미터로 전달받은 작업 목록(jobs)을 어떤 순서대로 처리해야 가장 최소의 평균시간을 찾을 수 있는지를 파악해야 한다.수행중인 작업이 없다면 먼저 들어온 작업을 우선 처리해야 하고, 수행중인 작업이 있으면 그 작업이 끝나는 시점까지 들어오는 요청들을 처리시간의 오름차순으로 정렬해서 대기열에 삽입 후 순서대로 수행한다.jobs의 요소는 [작업이 요청되는 시점, 작업의 소요시간] 형태이므로 작업이 요청되는 시점으로 언제 대기열에 넣을 것인지, 작업의 소요시간으로 대기열 내에서의 수행 순서를 계산한다.중요한 점은 작업 목록 jobs는 요청 시간이 정렬되어 있지 않다. (예) [[7, 8], [3, 5], [9, 6]]) 수행중인 작업이 없다면 먼저 들어온 작업을 우선 처리해야 하므로 요청 시간의 오름차순으로 정렬하도록 한다.1️⃣ 파라미터로 받은 배열을 순회하며 조건에 따라 새로운 배열에 삽입하고 정렬하기 위해 필요한 변수를 선언한다.const solution = (jobs) =&gt; { // 작업의 대기열 역할을 할 변수 선언 및 초기화를 수행한다. const priorityQueue = []; // time : 작업을 수행하며 현재 시점이 언제인지 저장한다. 즉, 처음 0ms에서 시작하여 3ms만큼 걸리는 작업을 수행하면 time을 3으로 갱신한다. // index : jobs를 반복하기 위한 인덱스다. // result : 각 작업의 총 수행 시간을 누적한다. 총 소요 시간은 작업 처리 시간과 대기 시간을 더한 값이다. 추후 평균 시간을 계산하기 위해 사용한다. let time = 0, index = 0, result = 0;};2️⃣ 먼저 들어온 작업을 우선 처리하기 위해 요청 시간의 오름차순 정렬한다.수행중인 작업이 없다면 먼저 들어온 작업을 우선 처리해야 하므로 요청 시간이 빠른 순으로 정렬이 필요하다.요소 형태는 [작업이 요청되는 시점, 작업의 소요시간]이므로 0번째 요소로 비교한다.[[7, 8], [3, 5], [9, 6]]라는 작업 목록이 전달되면 [[3, 5], [7, 8], [9, 6]]로 정렬된다. 이 작업 목록은 3ms에 처음 작업 요청을 한 것이다.jobs.sort((a, b) =&gt; a[0] - b[0]);3️⃣ 현재 시점 이전에 들어온 작업을 대기열에 삽입하고, 대기열 내에서 가장 소요 시간이 짧은 작업을 앞으로 보낸다.// 현재 시점과 가장 빠른 요청 시간이 같거나 크면 현재 시점 이전에 들어온 작업을 대기열에 삽입한다.if (index &lt; jobs.length &amp;&amp; time &gt;= jobs[index][0]) { priorityQueue.push(jobs[index++]); // 짧은 소요시간이 먼저 처리되어야 하므로 소요시간의 오름차순으로 정렬한다. priorityQueue.sort((a, b) =&gt; a[1] - b[1]); continue;}4️⃣ 대기열에 있는 작업을 수행하며 시점과 총 작업 시간을 갱신한다.현재 시점에서 대기열로 추가할 작업이 없다면 가장 짧은 시간이 소요되는 작업을 수행해야 하는 시점이므로 대기열의 첫 번째 요소를 제거한다. 작업이 수행된 것이므로 작업이 완료된 후의 시점과 해당 작업에 소요된 시간을 계산하여 각각 변수에 가산한다.if (priorityQueue.length &gt; 0) { const [requestTime, workingTime] = priorityQueue.shift(); time += workingTime; result += time - requestTime;}5️⃣ 현재 시점 기준 이전에 들어온 작업이 없고, 대기열에서 수행할 작업이 없다면현재 방문한 jobs 요소의 요청 시간을 현재 시점으로 업데이트한다.예를 들어, [[3, 5], [7, 8], [9, 6]]라는 작업 목록은 첫 번째로 수행할 작업이 3ms 시점에 요청한다. 현재 시점이 0ms라면 현재 시점을 3ms로 업데이트 후 대기열에 삽입 및 처리할 수 있도록 한다.else { time = jobs[index][0];}🏹 코드우선순위 큐로 구현하려고 했는데 막혀서 다른 블로그에서 배열을 활용한 풀이를 참고해서 해결했다. 🐝 참고 [프로그래머스/Javascript] 디스크 컨트롤러const solution = (jobs) =&gt; { const priorityQueue = []; let time = 0, index = 0, result = 0; jobs.sort((a, b) =&gt; a[0] - b[0]); // jobs 순회를 끝내지 않았거나 대기열이 비어있지 않으면 작업을 계속 수행한다. while (index &lt; jobs.length || priorityQueue.length &gt; 0) { if (index &lt; jobs.length &amp;&amp; time &gt;= jobs[index][0]) { priorityQueue.push(jobs[index++]); priorityQueue.sort((a, b) =&gt; a[1] - b[1]); continue; } if (priorityQueue.length &gt; 0) { const [requestTime, workingTime] = priorityQueue.shift(); time += workingTime; result += time - requestTime; } else { time = jobs[index][0]; } } // result는 각 작업의 총 소요 시간을 누적되어있으므로 평균을 위해 작업의 수만큼 나눈 후 반환한다. return parseInt(result / jobs.length);};⛳️ 더 좋은 해결책위에서 언급한대로 원래는 힙으로 구현하려고 하였다. 클래스로 Heap을 선언하고 작업 목록을 순회하며 해결한 포스트를 발견하여 남겨둔다.Heap 클래스를 사용하면 배열의 shift나 sort 작업을 하지 않으므로 더 빠르다.(참고 : 배열로 구현한 코드를 참고한 블로그의 댓글)직접 각각의 코드를 돌려보면 아래와 같이 나온다. 테스트 케이스를 알 수 없으나, 중간중간 힙을 사용할 것과 배열로 사용한 것의 시간이 크게 차이나는 케이스가 보이는데 아마 작업 데이터가 많이 들어온 케이스가 아닐까 생각이 든다. 더 좋은 해결책이라기 보다는 내가 해결하지 못한 방법으로 충분히 해결 가능하다는 것을 인지하기 위해 남겨둔다! 🐝 참고 [javascript] 프로그래머스 디스크 컨트롤러" }, { "title": "📸 2022-10-30", "url": "/posts/221030TIL/", "categories": "TIL", "tags": "타입스크립트", "date": "2022-10-30 23:33:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? TypeScript 컴파일러🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? compilerOptions의 lib을 특정 JS 버전으로 설정하면 그 버전에 맞는 라이브러리를 기본 값으로 사용할 수 있다. lib : []처럼 빈 배열을 할당한다면 특정 값(DOM 요소를 참조하는 메서드 등)들은 사용할 수 없다. 🐝 참고 [ Typescript ] 컴파일러 옵션 세팅하기 타입스크립트 블록체인 첼린지 -노마드코더 d.ts 파일의 역할은? 타입이 지정되지 않은 자바스크립트 모듈을 타입스크립트에서 사용하기 위해 타입 선언(declaration)만을 하는 파일 ts 파일에서 타입을 선언하고 import해서 사용해도 결과는 동일하지만, ts 파일이기에 컴파일 후 불필요한 js 파일이 생성된다. 🐝 참고 [예전 글 다시쓰기] .d.ts 파일이란? 🌟 내일은 어떻게 해보고 싶으세요? 타입스크립트 강의 계속 듣기" }, { "title": "📸 2022-10-27", "url": "/posts/221027TIL/", "categories": "TIL", "tags": "타입스크립트", "date": "2022-10-27 23:03:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? TypeScript 컴파일러 빠른 웹 사이트를 만들기 위해 알면 좋은 ‘세 가지 원리’🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 서버 응답을 최적화하기 위한 방법 중 하나인 CDN이 무엇인지? CDN은 서버와 사용자 사이의 물리적인 거리를 줄여 콘텐츠 로딩에 소요되는 시간을 최소화한다. 먼저 캐시 서버를 설치한 다음, 원본 서버와 멀리 있는 사용자가 웹사이트에 접속할 때 캐시 서버가 콘텐츠를 전달한다. CDN 자체가 알아서 사용자와 가장 가까운 캐시 서버에서 정보를 찾아 보내는 것이다. 🐝 참고 나무위키 CDN 가비아 라이브러리 - [클라우드 이해] CDN이란? [HTTP 기초] CDN 이란? 🌟 내일은 어떻게 해보고 싶으세요?빠른 웹 사이트를 만들기 위해 알면 좋은 ‘세 가지 원리’ 원글 : 빠른 웹 사이트를 만들기 위해 알면 좋은 ‘세 가지 원리’1️⃣ 웹 리소스의 크기 줄이기스크립트를 최소화하자. 개발 시에는 가독성을 위해 클린 코드, 컨벤션을 이용하지만 브라우저가 실행할 때에는 문법만 틀리지 않으면 문제가 없으므로 불필요한 주석, 개행 문자 등을 삭제하여 크기를 최소화하는 것이 좋다.알맞은 크기의 이미지를 사용하자. 썸네일 이미지를 원본으로 그대로 사용하는 경우가 있는데 이는 다운로드 바이트의 낭비다. 필요에 따라 동일한 이미지를 해상도에 맞게 변환하여 사용하자.2️⃣ 서버 측 응답을 최적화하기느린 서버는 결국 모든 웹 성능 안티 패턴의 원인이다. 특히 쿼리 튜닝을 수행하는 것이 중요하다.Preload를 사용하자.3️⃣ 사용자 환경에 맞는 콘텐츠로 최적화하기브라우저에 최적화된 이미지 형식을 사용하면 웹 리소스를 줄일 수 있다. 크롬 브라우저에 최적화된 이미지 형식은 WebP이다. 이 외 AVIF도 있다." }, { "title": "타입스크립트의 심화 - 컴파일러", "url": "/posts/config-of-typescript/", "categories": "study", "tags": "타입스크립트", "date": "2022-10-27 18:43:00 +0900", "snippet": " ✍️ Typescript :기초부터 실전형 프로젝트까지 with React + NodeJS 강의를 보면서 정리하는 글🚧⚒️🔧🔨🚜🦺👷🏻 정리중…관찰 모드 (watch)--watch 또는 -w를 사용하면 타입스크립트가 파일을 관찰하고 파일에 변경 사항이 있을 때마다 다시 컴파일한다. 관찰 모드는 종료하지 않는 ts 파일의 업데이트를 감지한다.tsc app.ts --watchtsc app.ts -w다수의 파일을 컴파일해야 한다면tsc 파일명1, 파일명2, ...와 같이 컴파일 할 파일들을 나열한다.tsc app.ts extra.ts특정 파일을 지정하지 않고 프로젝트의 모든 타입스크립트 .ts 파일을 컴파일하기 위해서는tsc --init으로 해당 경로를 타입스크립트 프로젝트라고 초기화한다. 이 명령어를 수행하면 tsconfig.json 파일이 생성된다. 이 파일은 프로젝트를 컴파일하는 데 필요한 옵션을 지정한다.tsc를 실행하면 해당 경로와 하위에 있는 ts파일들을 컴파일한다.tsc --init 후 tsc --watch(또는 -w)로 모든 파일에 대해 관찰 모드를 실행할 수 있다.tsconfig.json의 여러 옵션들 compilerOptions 타입스크립트 코드가 컴파일되는 방식을 관리한다. target : 컴파일 후 생성되는 자바스크립트의 버전 lib : 설정이 안 되어 있으면 기본 설정은 target 설정에 따라 달라진다.es6로 설정한 경우, es6에서 전역적으로 사용 가능한 모든 기능을 타입스크립트에서도 사용할 수 있다. 🐝 lib 설정에 대한 자세한 설명은 아래 블로그 참고 [Typescript] tsconfig.json의 lib include tsc를 실행하여 컴파일에 포함시킬 파일 또는 경로를 지정한다. exclude tsc를 실행하여 컴파일 시 포함되어서는 안되는 파일 또는 경로를 지정한다. exclude 속성에 디렉토리가 지정되지 있지 않다면 기본적으로 node_modules, bower_components, jspm_packages 그리고 &lt;outDir&gt;를 제외합니다. include에 지정한 파일이나 패턴을 제외시킬 수 있다. 주의할 점은 include에 지정하지 않은 파일은 적용되지 않는 점이다. \"exclude\" : [ \"extra.ts\", \"node_modules\", /* node_modules 디렉토리 내 모든 파일 무시 */ \"*.dev.ts\" /* dev.ts가 포함된 모든 파일 무시 */] files 컴파일 할 개별 파일들을 지정한다. \"files\": [ \"app.ts\", \"types.ts\"] 🐝 참고 tsconfig.json { tsconfig.json } 제대로 알고 사용하기" }, { "title": "🏄🏻‍♀️ [자바스크립트] 이중 우선순위 큐", "url": "/posts/baekjoon-7662/", "categories": "코딩테스트", "tags": "코테, 백준", "date": "2022-10-18 19:17:00 +0900", "snippet": "📄 문제골드 IV 이중 우선순위 큐구현해야 하는 것은명렁어에 따라 최댓값을 삭제하거나 최솟값을 삭제해야 한다. 따라서 최대힙과 최소힙을 각각 구성한다. 어느 한 쪽의 힙에서 최댓(최솟)값이 제거되면 나머지 힙에서도 제거되어야 하는 값이다. 이를 위해 삽입한 값의 삭제 여부를 관리할 수 있는 객체를 생성한다.중앙에 삽입된 값의 제거 여부를 관리하는 저장소를 두고 있고 각각의 힙에서 제거된 값이 있으면 나 이 값 제거했어! 하고 알려주면 그 저장소는 제거된 값이라는 표시로 갱신한다고 생각하면 된다.삽입 시에는 count를 증가시키고 제거되는 시점에 count를 감소시킨다. 명령을 다 수행한 뒤에 이 저장소에 담긴 값을 활용해서 count가 0보다 큰 경우는 아직 힙에 남아있는 값이 되고, 그 중에 가장 앞에 있는 값이 최댓(최솟)값이 된다.파라미터로 전달받은 값을 활용해서 최대 힙과 최소 힙을 각각 생성한다.우선순위 큐의 기능을 담은 클래스를 생성하여 값을 삽입하거나 제거하며 발생하는 정렬 함수만 매개변수로 전달한다.class PriorityQueue { constructor(compare) { this.heap = [null]; this.compare = compare; } /* ... */}/* ... */const maxHeap = new PriorityQueue((a, b) =&gt; a &gt; b);const minHeap = new PriorityQueue((a, b) =&gt; a &lt; b);/* ... */최대값 또는 최소값이 큐에서 제거되면 제거되었음을 저장할 객체가 필요하다.최대값을 삭제하는 연산(D 1)은 최대힙에서만 값이 삭제되고, 최소값을 삭제하는 연산(D -1) 역시 최소힙에서만 값이 삭제된다. 그렇기 때문에 상대힙에게 제거된 값을 알려주기 위해 제거되었음을 담고 있을 객체를 생성해야 한다.값을 삽입하는 연산(I 정수N)을 수행할 때 해당 정수값이 삽입되었음을 아래처럼 저장해둔다.const valid = {};if (command === \"I\") { maxHeap.push(+num); minHeap.push(+num); // 👇 삽입된 값의 count를 증가시킨다. 특정 정수가 삽입되면 { num : 1 } 이런 식으로 저장된다. valid[+num] = (valid[+num] || 0) + 1;}그리고 삭제 연산이 발생한 경우 이 count를 감소시키면 된다.즉 I 100 연산으로 최대/최소힙에 1이라는 값이 삽입되면 { 100 : 1 }이 될 것이고, D 연산으로 어느 힙에서든 100이라는 값이 제거가 된다면 { 100 : 0 }이 된다.그러므로 제거하려는 값의 count를 확인했는데 0이면 상대 힙에서 이미 제거했다는 의미다. 그러므로 본인의 리스트에서도 그 값을 제거한 후에 양쪽에서 제거되지 않은 값을 찾을 때까지 계속 dequeue 작업을 해줘야 한다.while (!heap.empty()) { const popedItem = heap.pop(); // 👇 0보다 큰다는 것은 최대/최소힙에 아직 남아있는 값이다. if (valid[popedItem] &gt; 0) { valid[popedItem]--; break; }}명령어를 모두 수행한 뒤에 최대/최소힙에 남은 값과 그 값의 삭제 여부를 확인해서 삭제되지 않았고 힙에서 가장 앞에 있는 값을 출력하면 된다.// 👇 힙의 가장 첫 번째 값의 제거 여부를 확인 후에 제거되지 않은 값을 찾을 때까지 dequeue 작업을 반복한다.while (!heap.empty() &amp;&amp; valid[heap.top()] === 0) { heap.pop();}// 👇 힙이 둘 다 비어있으면 EMPTY를 출력한다.if (maxHeap.empty() &amp;&amp; minHeap.empty()) { result.push(\"EMPTY\");} else { // 👇 top()으로 각 힙에서 가장 첫 번째에 있는 값을 출력한다. result.push(`${maxHeap.top()} ${minHeap.top()}`);}🏹 코드const readline = require(\"readline\");const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});class PriorityQueue { constructor(compare) { this.heap = [null]; this.compare = compare; } swap(a, b) { [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]]; } empty() { return this.heap.length === 1; } top() { return this.heap[1]; } push(item) { this.heap.push(item); this.heapifyUp(); } heapifyUp() { let currentIndex = this.heap.length - 1; let parentIndex = Math.floor(currentIndex / 2); while ( currentIndex &gt; 1 &amp;&amp; this.compare(this.heap[currentIndex], this.heap[parentIndex]) ) { this.swap(currentIndex, parentIndex); currentIndex = parentIndex; parentIndex = Math.floor(currentIndex / 2); } } pop() { if (this.heap.length === 1) return; if (this.heap.length === 2) return this.heap.pop(); const result = this.heap[1]; this.heap[1] = this.heap.pop(); this.heapifyDown(); return result; } heapifyDown() { let currentIndex = 1; let leftChildIndex = currentIndex * 2; let rightChildIndex = currentIndex * 2 + 1; if (!this.heap[leftChildIndex]) return; while ( currentIndex &lt; this.heap.length &amp;&amp; (this.compare(this.heap[leftChildIndex], this.heap[currentIndex]) || this.compare(this.heap[rightChildIndex], this.heap[currentIndex])) ) { let compareIndex; if (rightChildIndex &gt; this.heap.length - 1) { compareIndex = leftChildIndex; } else { compareIndex = this.compare( this.heap[leftChildIndex], this.heap[rightChildIndex] ) ? leftChildIndex : rightChildIndex; } this.swap(currentIndex, compareIndex); currentIndex = compareIndex; leftChildIndex = currentIndex * 2; rightChildIndex = currentIndex * 2 + 1; } }}let maxHeap = new PriorityQueue((a, b) =&gt; a &gt; b);let minHeap = new PriorityQueue((a, b) =&gt; a &lt; b);let valid = {};const result = [];let t = null, k = 0;const enqueue = (value) =&gt; { // 👇 최대/최소힙에 값을 삽입하고 값의 삭제 여부를 관리하는 객체(valid)에 삽입되었음(count 증가)으로 갱신한다. maxHeap.push(value); minHeap.push(value); valid[value] = (valid[value] || 0) + 1;};const dequeue = (heap) =&gt; { // 👇 제거하려던 값이 다른 힙에서 이미 제거된 값이면 본인 힙에서도 제거한 후에 아직 양쪽 힙에 남아있는 값을 찾아서 제거한다. while (!heap.empty()) { const popedItem = heap.pop(); if (valid[popedItem] &gt; 0) { valid[popedItem]--; break; } }};const removeDummyDataInHeap = (heap) =&gt; { // 👇 현재 힙의 첫 번째 값이 제거된 값인지 확인하고 유효한 값이 나올 때까지 필요없는 값은 제거한다. while (!heap.empty() &amp;&amp; valid[heap.top()] === 0) { heap.pop(); }};rl.on(\"line\", (line) =&gt; { if (!t) { t = +line; return; } if (k === 0) { k = +line; maxHeap = new PriorityQueue((a, b) =&gt; a &gt; b); minHeap = new PriorityQueue((a, b) =&gt; a &lt; b); valid = {}; return; } const [command, num] = line.split(\" \"); if (command === \"I\") { enqueue(+num); } else if (+num === 1) { dequeue(maxHeap); } else if (+num === -1) { dequeue(minHeap); } if (--k === 0) { removeDummyDataInHeap(maxHeap); removeDummyDataInHeap(minHeap); if (maxHeap.empty() &amp;&amp; minHeap.empty()) { result.push(\"EMPTY\"); } else { result.push(`${maxHeap.top()} ${minHeap.top()}`); } }}).on(\"close\", () =&gt; { console.log(result.join(\"\\n\")); process.exit();});🤦🏻‍♀️ 시행착오최대 값과 최소 값을 각각 어떻게 관리할까처음에는 하나의 우선순위 큐로 최대값과 최소값을 제거해나가면서 최종적인 답을 찾으려고 했는데 도저히 생각이 나지 않았다. 그래서 검색해보니 최대/최소힙을 각자 구성하고 따로 객체 생성해서 제거된 값을 관리하는 방법을 찾았다. 🐝 참고 [백준] 이중 우선순위 큐(7662)메모리 초과가 계속 발생한다면 모듈 확인하기3개월 전에 실패하고 3주 전에도 실패하며 오늘은 꼭 해결해야겠다 생각하며 반나절을 다 보냈다. 계속 메모리 초과가 발생했고 원인을 찾으려고 한 줄씩 주석치면서 찾았지만 결국 찾지 못했고 다른 분의 코드를 보면서 fs 모듈이 아닌 readline 모듈을 사용해야 한다는 것을 알 수 있었다.가끔 백준 문제를 풀 때 모듈 사용으로 인해 시간을 많이 소요하면 힘이 빠질 때도 있지만.. 자주 안풀어서 까먹었던 내 탓이니까.." }, { "title": "📸 2022-10-18", "url": "/posts/221018TIL/", "categories": "TIL", "tags": "코테, 백준", "date": "2022-10-18 19:16:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 백준 이중 우선순위 큐 - Javascript🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?" }, { "title": "📸 2022-10-17", "url": "/posts/221017TIL/", "categories": "TIL", "tags": "", "date": "2022-10-17 22:00:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 📖 어떤 개발자가 살아남는가 완독 백준 이중 우선순위 큐 - Javascript 3번째 시도중.. 아직 해결 못함..😩🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?최근 미쳤나 싶을 정도로 공부를 안했다. 9월 내내 여러 코딩테스트나 과제테스트를 치르고 이제 다 끝나니 마음이 놓인건지(합격한 것도 아닌데 근거없는 자신감)다시 마음 다잡고 시작해야겠다.📖 어떤 개발자가 살아남는가 🐝 책 정보도서관 갔다가 신착도서 책장에서 발견한 책! 제목보고 끌려서 앞부분만 읽으려다가 3일만에 다 읽었다. 책을 열면 프로그래밍을 하는 자가 될 것인가, 프로그래밍을 당하는 자가 될 것인가 라는 문구를 볼 수 있다. 왠지 모르게 양심이 찔리기도 했고.. IT 기술서만 많이 봤지 이 책처럼 인문학과 프로그래밍을 함께 이야기하는 책을 읽은 적이 없어서 새롭고 흥미로웠다." }, { "title": "📸 2022-10-14", "url": "/posts/221014TIL/", "categories": "TIL", "tags": "", "date": "2022-10-14 16:47:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 📖 지구는 괜찮아, 우리가 문제지 완독🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?📖 지구는 괜찮아, 우리가 문제지 🐝 책 정보 🔖 p.148 COP1부터 COP25까지 진행되는 30년에 가까운 시간 동안 온실기체 배출량은 계속해서 늘어났고, 기후변화 문제는 점점 더 심각해졌다. 🔖 p.265 나는 기후변화 문제를 해결해나가는 다른 기술 분야의 발전에도 비슷한 방향의 전략을 기대할 필요가 있다고 생각한다. 계획대로 가두어놓고, 틀에 맞추어 제약하는 방식이 아니라 여러 가지 기술을 좀 더 자유롭게 시도해보게 하는 제도가 꼭 필요할 때가 있다. 다양한 분야의 기술이 자유롭게 발전하고, 새로운 기술이 다양하게 활용되고 시도될 수 있는 상황이 주어질 때, 의외로 문제를 해결할 수 있는 새로운 생각이 등장할 가능성이 더 높아질 것이다. 🔖 p.347 장래에 기후변화를 막기 위해 전 세계에 이산화탄소 흡수 장치를 설치하라는 식으로 돈을 들여야 하는 조치가 별 고려 없이 강제된다면, 결국 개발도상국들은 자기 나라 국민들에게 줄 월급을 아껴 그 돈으로 선진국, 강대국으로부터 장치를 사 와야 한다. 🔖 p.385 당연한 이야기이지만 정부는 국민의 생명을 구하는 의무를 다해야 한다. 매년 여름 비가 많이 오면, 흙탕물이 역류해서 집 안으로 쏟아지는 반지하 집들이 있는데, 앞으로 기후변화 때문에 비가 더 많이 올 거라고 모든 사람이 예상하고 있으며, 심지어 정부기관 스스로도 같은 예측을 발표하는데, 정ㅈ부에서 아무 조치를 취하지 않아도 되는가? 🔖 p.432 이제는 어떤 정책을 만들거나 정치적 결단을 내릴 때 그 결정의 탄소 발자국을 같이 계산할 필요가 있는 시대다. 🔖 p.434 (1) 기후변화 문제는 혼자서 해결할 수 없어서 여러 나라가 같이 해결해야 한다. (2) 강대국과 선진국은 기후변화 문제를 자기 나라의 이익이 되도록 활용하려고 한다. (3) 기후변화는 약자들부터 피해를 입히는데, 기후변화를 막는 조치 역시도 자칫 잘못하면 약자들에게 불리할 수 있다. 🔖 p.435 기후변화를 줄이기 위해 애쓰는 내 노력이 실제로 득이 되려면, 내 노력이 주변에 영향을 끼치고 그래서 더 많은 사람이 노력에 동참하도록 해야 한다. 나아가 그러한 관심과 이해가 중요한 과제로 자리 잡아, 정부의 관심사가 되어야 한다. 그렇게 해서, 한 나라의 정부가 적극적으로 외교 분야에서 활약하며 세계가 같이 기후변화를 막을 수 있도록 함께 움직이게 되는 편이 좋다. 🔖 p.439 기후변화로 인한 재난을 생각할 때, 귀여운 북극곰들이 당황하는 모습만을 떠올리기보다는, 급작스러운 집중호우에 배수가 역류하는 도시의 반지하 방에 사는 사람들을 어떻게 보호할 수 있을 것인지 먼저 따져보아야 한다는 뜻이라고 말해볼 수도 있겠다." }, { "title": "📸 2022-10-01", "url": "/posts/221001TIL/", "categories": "TIL", "tags": "자료구조, 힙, 우선순위큐", "date": "2022-10-01 16:53:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 2022 LG유플러스 개발자 채용 챌린지 2022년 한국주택금융공사 하반기 코딩테스트🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? mutual friend : 공통의 친구. 나의 친구도 되고 또 다른 사람의 친구도 되는 그 친구를 말한다. 처음 알게 된 단어라 궁금해서 구글에 검색하는데 자동완성으로 mutual friend 알고리즘이 밑에 떴다. 별 게 다 있구나 싶어서 검색해봤는데 알고리즘으로 딱 정의된 거 같지는 않았다.🤔 🌟 내일은 어떻게 해보고 싶으세요? 휴식2022 LG유플러스 개발자 채용 챌린지과 2022년 한국주택금융공사 하반기 코딩테스트2022 LG유플러스 개발자 채용 챌린지 - 코딩 테스트총 4문제였고 주어진 시간은 3시간이었다.첫 번째 문제는 정규식을 활용하였다. 숫자와 괄호로 활용해 압축되어 있는 문자열을 원래 문자열로 풀어내는 것이었다. 숫자 + 여는 괄호 + 문자열 + 닫는 괄호의 형태로 가장 안쪽에서부터 압축을 풀었다. 그리고 문자열을 숫자만큼 반복해야 했기 때문에 repeat을 사용했다.두 번째 문제는 anagram 문제였다. 처음에 주어진 배열을 다 돌면서 찾으니 시간 초과가 떴다ㅠㅠ 그래서 배열에 담긴 숫자들을 정렬했다.(ex. 321 -&gt; 123) 그러면 완전 일치하는 문자열은 서로 anagram이기 때문에 쉽게 찾을 수 있었다. 배열에서 같은 값을 갖는 요소들의 갯수를 파악하기 위해서 Map을 사용했다.세 번째 문제는 파라미터로 주어진 2차원 배열의 각 요소가 동서남북 중 한 방향을 가리키고 서로 마주 보는 사람이 없게 최소한의 변경 횟수를 구해야 했다. 어려워서 구현하지 못했다..네 번째 문제는 토너먼트인데 우선순위가 주어진 요소가 있었다. 해결 방법 조차 생각해내지 못했다. 어려웠다…2022년 한국주택금융공사 하반기 - 과제 테스트총 4문제였고 주어진 시간은 2시간이었다. 너무.. 짧았다…상반기보다 쉬웠다고 느꼈다. 4문제 중에 3문제를 우선 제출은 했는데.. 이게 통과했을지도 확인을 못하니 계속 궁금하긴 하다.대부분 배열이나 객체를 반복하면서 값을 누적해서 원하는 요소를 찾아내거나 최소/최대값을 찾아내는 문제들이었다. 한 시간만 더 있었어도 마지막 문제를 풀 수 있었을 거 같은데 결국 풀지 못했다… 그래서 아쉽다" }, { "title": "📸 2022-09-28", "url": "/posts/220928TIL/", "categories": "TIL", "tags": "자료구조, 힙, 우선순위큐", "date": "2022-09-28 23:28:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 최대힙 구현하기 최소힙으로 우선순위큐 구현하기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 우선순위 큐를 구현하며 dequeue 메서드에서 자식 노드의 우선순위 프로퍼티를 찾을 때 먼저 노드 자체가 존재하는지를 확인하는 것이 아니라 옵셔널 체이닝(?.)으로 노드가 있으면 우선순위를 반환하고 그렇지 않으면 undefined를 반환하도록 해서 비교문을 구현했다. 논리 상 문제는 없는 거 같은데 노드 자체의 존재 평가를 우선적으로 처리하지 않아도 되는지 확인해봐야한다.🌟 내일은 어떻게 해보고 싶으세요? 우선순위 큐 관련 코딩테스트 연습 문제 해결해보기" }, { "title": "최소힙으로 우선순위 큐 구현하기", "url": "/posts/data-structure-priority-queue/", "categories": "study", "tags": "자료구조, 힙, 우선순위큐", "date": "2022-09-28 20:55:00 +0900", "snippet": " ✍️ JavaScript 알고리즘 &amp; 자료구조 마스터클래스 강의를 보면서 정리하는 글우선순위 큐(Priority Queue)우선순위 큐는 각 요소가 그에 해당하는 우선순위를 가지는 데이터 구조이다. 더 높은 우선순위를 가진 요소가 먼저 처리된다.최소 힙으로 우선순위 큐 구현하기 최대힙을 최소힙으로 변경하고 비교문을 노드 자체가 아닌 우선순위 프로퍼티끼리 비교하도록 수정해주면 된다. 낮은 숫자는 우선순위가 높음을 의미하므로 최소 힙으로 구현하도록 한다. 각 요소는 값과 우선순위를 저장할 객체 단위로 요소를 관리한다.class Node { constructor(value, priority) { this.value = value; this.priority = priority; }}class PriorityQueue { constructor() { this.list = [null]; } // 최대 힙에서 만든 swap 메서드 그대로 사용하기 swap(a, b) { [this.list[a], this.list[b]] = [this.list[b], this.list[a]]; }}⛳️ Enqueueclass PriorityQueue { enqueue(value, priority) { // ✅ 노드는 값과 우선순위를 담는 node 인스턴스로 구성된다. const newNode = new Node(value, priority); this.list.push(newNode); let curIdx = this.list.length - 1; let parIdx = Math.floor(curIdx / 2); // ✅ 부모와 자식 간 값 비교는 요소 자체가 아닌 요소의 우선순위 프로퍼티끼리 비교한다. while ( curIdx &gt; 1 &amp;&amp; this.list[curIdx].priority &lt; this.list[parIdx].priority ) { this.swap(curIdx, parIdx); curIdx = parIdx; parIdx = Math.floor(curIdx / 2); } }}🗑 Dequeueclass PriorityQueue { dequeue() { const min = this.list[1]; if (this.list.length &lt;= 2) { this.list = [null]; return min; } this.list[1] = this.list.pop(); let curIdx = 1; let leftIdx = curIdx * 2; let rightIdx = curIdx * 2 + 1; if (!this.list[leftIdx]) { return min; } else if (!this.list[rightIdx]) { // ✅ 부모와 자식 간 값 비교는 요소 자체가 아닌 요소의 우선순위 프로퍼티끼리 비교한다. if (this.list[leftIdx].priority &lt; this.list[curIdx].priority) { this.swap(leftIdx, curIdx); } return min; } // ✅🌟 자식 노드는 존재하지 않을 수도 있다. 노드가 존재하지 않는데 priority라는 속성을 불러오면 에러가 발생한다. // 자바스크립트의 옵셔널 체이닝 ?.을 사용하여 오류를 방지한다. while ( this.list[leftIdx]?.priority &lt; this.list[curIdx].priority || this.list[rightIdx]?.priority &lt; this.list[curIdx].priority ) { // ✅ 노드 비교는 요소 자체가 아닌 요소의 우선순위 프로퍼티끼리 비교한다. const minIdx = this.list[leftIdx].priority &gt; this.list[rightIdx].priority ? rightIdx : leftIdx; // ✅ 부모와 자식 간 값 비교는 요소 자체가 아닌 요소의 우선순위 프로퍼티끼리 비교한다. if (this.list[minIdx].priority &lt; this.list[curIdx].priority) { this.swap(minIdx, curIdx); curIdx = minIdx; leftIdx = curIdx * 2; rightIdx = curIdx * 2 + 1; } } return min; }} 전체 코드 : https://codesandbox.io/s/data-structure-by-javascript-gv68jw?file=/src/priorityQueue.js" }, { "title": "힙 구현하기", "url": "/posts/data-structure-heap/", "categories": "study", "tags": "자료구조, 힙", "date": "2022-09-28 19:11:00 +0900", "snippet": " ✍️ JavaScript 알고리즘 &amp; 자료구조 마스터클래스 강의를 보면서 정리하는 글힙(Heap)힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기본으로 한 자료구조다. 완전이진트리는 마지막 레벨을 제외한 모든 노드들은 꽉 채워져 있고 마지막 레벨의 모든 노드는 가능한 한 가장 왼쪽에 있다.최대힙과 최소힙 최대힙부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리 최소힙부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리이진 탐색 트리와의 차이점 (최대힙과 비교하기)이진 탐색 트리는 왼쪽 자식은 부모보다 작아야 하고 오른쪽 노드는 부모보다 커야 한다. 최대 힙은 부모보다 작기만 하면 된다. 즉, 형제 노드 사이에는 순서가 없다.최대 힙의 부모와 자식 찾아보기최대 힙을 트리로 표현하면 아래 그림과 같다. 그리고 그림 하단의 배열이 힙을 배열로 구현하였을 때의 형태이다.여기서 5번 노드는 값으로 68을 가지며 3번 노드의 65보다 큰 값이지만 더 아래 레벨에 위치한다. 자식 노드는 부모 노드보다 작기만 하면 되므로 2번 노드의 값 70보다 5번 노드의 값 68이 작으므로 문제가 되지 않는다.힙을 배열로 표현하면 현재 노드에서 부모 노드나 자식 노드의 위치를 알기 수월하다. 힙을 구현할 배열의 0번째 칸은 비워둔다고 가정하면 자식 노드를 찾기 위해서는 현재 노드의 인덱스(값이 아닌 인덱스!)에 2를 곱하면 찾을 수 있다. 왼쪽 노드와 오른쪽 노드는 붙어있고 왼쪽 노드가 먼저 채워지기 때문에 순서대로 왼쪽, 오른쪽 노드의 위치를 파악할 수 있다.반대로 부모 노드를 찾기 위해서는 2를 나누면 된다. 자바스크립트는 정수 / 2의 경우 소숫점이 생략되지 않으므로 Math.floor로 소숫점을 버려줘야 한다. 위에서 언급한 부모와 자식 노드의 인덱스를 찾는 식은 배열의 첫 번째 칸은 비웠을 때에만 해당한다.만약 배열을 처음부터 채웠다면 부모를 찾는 식은 부모 노드 = (인덱스 - 1) / 2이고 자식을 찾기 위해서는 왼쪽 노드 = 인덱스 * 2 + 1, 오른쪽 노드 = 인덱스 * 2 + 2이다.구현힙은 이진 탐색 트리와 다르게 노드 클래스를 생성하지 않아도 된다. 요소들을 저정할 배열(list)만 Heap 클래스의 프로퍼티로 생성한다.class MaxBinaryHeap { constructor() { // 👇 첫 번째 칸은 비어둘 것이므로 null 할당 this.list = [null]; }}⛳️ insert의사코드 1️⃣ 힙에 마지막 요소 뒤에 값을 삽입한다. 2️⃣ 알맞은 자리로 갈 때까지 부모 노드와 값을 비교하여 위치를 교환한다. 2️⃣-1 새로 삽입된 값의 인덱스를 할당할 변수를 생성한다. 2️⃣-2 비교할 부모 노드의 인덱스를 할당할 변수를 생성한다. 2️⃣-3 새 노드의 값이 부모 노드의 값보다 큰지 작은지 비교한다. ⭐️ 새 노드의 값 &lt; 부모 노드의 값 새 노드의 위치와 부모 노드의 위치를 교환한다. 부모 노드의 값을 현재 위치로 지정한 후 비교 작업을 반복한다. 코드class MaxBinaryHeap { insert(value) { // 1️⃣ 힙에 마지막 요소 뒤에 값을 삽입한다. this.list.push(value); // 2️⃣-1 새로 삽입된 값의 인덱스를 할당할 변수를 생성한다. let curIdx = this.list.length - 1; // 2️⃣-2 비교할 부모 노드의 인덱스를 할당할 변수를 생성한다. let parIdx = Math.floor(curIdx / 2); // 2️⃣-3 새 노드의 값이 부모 노드의 값보다 큰지 작은지 비교한다. // ⭐️ `새 노드의 값 &lt; 부모 노드의 값` while (curIdx &gt; 1 &amp;&amp; this.list[parIdx] &lt; this.list[curIdx]) { // 새 노드의 위치와 부모 노드의 위치를 교환한다. [this.list[parIdx], this.list[curIdx]] = [ this.list[curIdx], this.list[parIdx], ]; // 부모 노드의 값을 현재 위치로 지정한 후 비교 작업을 반복한다. curIdx = parIdx; parIdx = Math.floor(curIdx / 2); } }}🗑 remove의사코드 1️⃣ 힙에 최대 하나의 요소만 존재하면 해당 요소를 반환 후 종료한다. 2️⃣ 힙의 첫 번째 값과 마지막 값의 위치를 교환 후 힙의 마지막 요소를 제거한다. 3️⃣ 첫 번째 요소를 할당할 변수를 생성한다. 4️⃣ 현재 노드의 자식 노드를 찾고 값을 비교하여 위치를 교환한다. 4️⃣-1 자식 노드가 하나도 없는 경우 최대 값을 반환 후 종료한다. 4️⃣-2 왼쪽 자식 노드만 존재하는 경우 왼쪽 자식 노드 값이 부모 노드의 값보다 큰지 작은지 비교한다. ⭐️ 자식 노드 &gt; 부모 노드 : 부모 노드와 위치를 교환한다. 4️⃣-3 왼쪽, 오른쪽 자식 노드가 모두 존재하는 경우 둘 중 더 큰 값을 찾아서 부모 노드의 값을 비교한다. ⭐️ 자식 노드 &gt; 부모 노드 : 부모 노드와 위치를 교환한다. 5️⃣ 부모 노드와 교환한 자식 노드의 값을 현재 위치로 지정한 후 비교 작업을 반복한다.코드class MaxBinaryHeap { remove() { const max = this.list[1]; // 1️⃣ 힙에 최대 하나의 요소만 존재하면 해당 요소를 반환 후 종료한다. if (this.list.length &lt;= 2) { this.list = [null]; return max; } // 2️⃣ 힙의 첫 번째 값과 마지막 값의 위치를 교환 후 힙의 마지막 요소를 제거한다. this.list[1] = this.list.pop(); let curIdx = 1; let leftIdx = curIdx * 2; let rightIdx = curIdx * 2 + 1; if (!this.list[leftIdx]) { // 4️⃣-1 자식 노드가 하나도 없는 경우 최대 값을 반환 후 종료한다. return max; } else if (!this.list[rightIdx]) { // 4️⃣-2 왼쪽 자식 노드만 존재하는 경우 왼쪽 자식 노드 값이 부모 노드의 값보다 큰지 작은지 비교한다. if (this.list[leftIdx] &gt; this.list[curIdx]) { // ⭐️ [자식 노드 &gt; 부모 노드] : 부모 노드와 위치를 교환한다. [this.list[leftIdx], this.list[curIdx]] = [ this.list[curIdx], this.list[leftIdx], ]; } return max; } while ( this.list[leftIdx] &gt; this.list[curIdx] || this.list[rightIdx] &gt; this.list[curIdx] ) { // 4️⃣-3 왼쪽, 오른쪽 자식 노드가 모두 존재하는 경우 둘 중 더 큰 값을 찾아서 부모 노드의 값을 비교한다. const maxIdx = this.list[leftIdx] &lt; this.list[rightIdx] ? rightIdx : leftIdx; if (this.list[maxIdx] &gt; this.list[curIdx]) { // ⭐️ [자식 노드 &gt; 부모 노드] : 부모 노드와 위치를 교환한다. [this.list[maxIdx], this.list[curIdx]] = [ this.list[curIdx], this.list[maxIdx], ]; // 5️⃣ 부모 노드와 교환한 자식 노드의 값을 현재 위치로 지정한 후 비교 작업을 반복한다. curIdx = maxIdx; leftIdx = curIdx * 2; rightIdx = curIdx * 2 + 1; } } return max; }}🔄 swap부모 노드와 자식 노드의 교환을 위해 자바스크립트의 구조 분해 할당 구문을 사용한다. insert와 remove 메서드 모두에서 여러 번 사용되어 swap하는 부분만 메서드로 분리한다.class MaxBinaryHeap { // 인덱스만 받아서 a는 b로, b는 a로 변경한다. swap(a, b) { [this.list[a], this.list[b]] = [this.list[b], this.list[a]]; } insert(value) { // ... while (curIdx &gt; 1 &amp;&amp; this.list[parIdx] &lt; this.list[curIdx]) { // 새 노드의 위치와 부모 노드의 위치를 교환한다. this.swap(parIdx, curIdx); // ... } } remove() { // ... // 4️⃣-2 왼쪽 자식 노드만 존재하는 경우 왼쪽 자식 노드 값이 부모 노드의 값보다 큰지 작은지 비교한다. if (this.list[leftIdx] &gt; this.list[curIdx]) { // ⭐️ [자식 노드 &gt; 부모 노드] : 부모 노드와 위치를 교환한다. this.swap(leftIdx, curIdx); } // ... while (/* ... */) { // ... if (this.list[maxIdx] &gt; this.list[curIdx]) { // ⭐️ [자식 노드 &gt; 부모 노드] : 부모 노드와 위치를 교환한다. this.swap(maxIdx, curIdx); // ... } } // ... }} 🐝 참고 [자료구조] JS로 구현하는 HEAP [자료구조] Heap(힙) - 개념, 종류, 활용 예시, 구현 전체 코드 : https://codesandbox.io/s/data-structure-by-javascript-gv68jw?file=/src/maxBinaryHeap.js" }, { "title": "📸 2022-09-26", "url": "/posts/220926TIL/", "categories": "TIL", "tags": "자바스크립트, 타입스크립트", "date": "2022-09-26 19:03:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 타입스크립트 기본 사용법 복습하기 참고한 블로그 👉 [ReactJS] 5. 𝒘𝒊𝒕𝒉 타입스크립트 타입스크립트 공부하기 좋은 사이트 👉 https://radlohead.gitbook.io/typescript-deep-dive/ 📖 지구는 괜찮아, 우리가 문제지 1,2장 읽기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 자바스크립트의 Nullish 병합 연산자 연산자 ??는 Nullish한 값 대신 지정된 대체 값을 반환한다. A ?? B : A가 Null이거나 undefined이면 B를 반환한다. ?? !== || : || 연산자는 왼쪽 값의 Truthy, Falsy을 판단하여 오른쪽 값을 반환한다. const a = 0 || 1; // 1const b = 0 ?? 1; // 0 자바스크립트의 옵셔널 체이닝 ?.은 ?.“앞”의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다. 타입스크립트의 문법인줄 알았는데 바닐라 자바스크립트에서도 사용할 수 있다.. 몰랐다..😲 🐝 참고 자바스크립트 null 병합 연산자와 옵셔널 체이닝 옵셔널 체이닝 ‘?.’ 🌟 내일은 어떻게 해보고 싶으세요? 자바스크립트 알고리즘 강의 듣고 코딩테스트 연습 문제 해결해보기 (이진 힙)📖 지구는 괜찮아, 우리가 문제지 🐝 책 정보 🔖 p.56 지금 와서 기후변화 문제가 급해졌으니까 갑자기 개발도상국에서 만드는 제품은 앞으로 금지하고, 선진국의 뛰어난 기술을 이용하는 제품만 허용하자고 주장한다면, 개발도상국에서는 불만을 품을 수밖에 없다. 🔖 p.65 우리가 기후변화와 관련된 재난과 사고로 희생되는 사람의 숫자를 줄이기 위해 기후변화 문제에 대한 대책을 세워야 하는 것이지, 분노한 지구가 인류를 징벌하는 최후의 순간을 피하기 위해, 경건한 마음으로 구름과 바람에 사죄하기 위해 기후변화 문제에 대처라는 것은 아니다. 🔖 p.75 기후변화를 이겨내려면 그냥 막연히 싱그러운 자연, 지구의 본모습에 대한 상상을 쫓는 것보다는 더 많은 노력이 필요하다. 그냥 착하게 산다고 해서 기후변화가 해결되지도 않고, 뭔가 자연적인 느낌이 드는 것을 추구한다고 해서 그게 무조건 기후변화 문제에서 이로운 행동이 되는 것도 아니다. 기후변화 문제를 해결하려면 그냥 자연으로 돌아갈 것이 아니라, 구체적으로 온실기체를 줄일 수 있는 방법을 찾아서 그 방법이 정말로 온실기체를 잘 줄일 수 있는지 살펴보고, 실행에 옮겨야 한다. 🔖 p.76 정말로 지구 전체를 두고 따져본다면, 기후변화에 대처하기 위해 우리가 해야 하는 행동은 죽어가는 지구를 살린다거나, 지구의 운명을 타락에서 구하는 것과는 거리가 있다. 그보다는 지구 역사의 최근에 등장해 겨우 적응하는 데 성공한 우리 사람 종족 스스로가 살아남기 위해 어떻게든 매달리는 일에 가깝지 않나 싶다." }, { "title": "📸 2022-09-24", "url": "/posts/220924TIL/", "categories": "TIL", "tags": "코딩테스트, 과제테스트", "date": "2022-09-24 23:11:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 2023 KAKAO BLIND RECRUITMENT 2022 자비스앤빌런즈 개발자 공개채용 챌린지 - 2차 과제 테스트🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 리액트로 라우터 설정할 때 BrowserRouter 관련 오류 : Error: You cannot render a inside another . You should never have more than one in your app.해결 방법은 이랬는데 내가 BrowserRouter를 index.js에서 전체 감싸고 또 App.js에서도 사용해서 그런 거 같다. index.js에서 설정한 기억이 왜 없어서 살짝 헤맸다.🌟 내일은 어떻게 해보고 싶으세요?2023 KAKAO BLIND RECRUITMENT과 2022 자비스앤빌런즈 개발자 공개채용 챌린지오늘 두 개의 테스트를 같은 시간에 봐야 해서 둘 다 시간이 촉박했다. 끝나고 보니 하나만 집중해서 해결해볼걸 생각이 들지만 여러 문제를 접할 수 있었고 좋은 경험이었다고 생각한다. 결론적으로 원하는만큼의 결과를 내지는 못했지만 여섯 시간동안 코딩하니 머리가 좀 아프긴 했다.KAKAO BLIND RECRUITMENT - 코딩 테스트총 7문제였고 주어진 시간은 5시간이었다. 처음 문제를 가볍게 훑어볼 때엔 저번보다 괜찮은 거 같다고 생각했는데 하나씩 자세히 보니 이번에도 어려웠다😅1번 문제는 날짜 차이를 구해서 주어진 개월 수를 초과하는지를 체크하는 문제였다. 1번 문제는 특별한 알고리즘 사용하지 않아도 되는 문제였다(고 생각한다..)그 후에 있던 문제들은 해결하지 못했다. 아쉬운 문제는 4번이다. 명령어와 값을 주고 2차원 배열의 해당 위치의 값을 수정하는 문제였다. 각 요소마다 객체로 병합 정보나 value 등을 저장하고 명령을 수행하게끔 했는데 MERGE와 UNMERGE 명령어에서 뭔가 꼬인건지 런타임 에러도 나고.. 해결할 수가 없었다.. 이 문제는 나중에 문제 풀리면 진짜 꼭 다시 풀어봐야겠다. 잊지말자2022 자비스앤빌런즈 개발자 공개채용 챌린지 - 과제 테스트이번 과제 테스트는 리액트와 타입스크립트를 사용하여 해결해야 했다. 타입스크립트로 코딩을 해본 적이 없어서 이틀?정도 벼락치기를 했다. 문제는 다른 과제 테스트와 비슷하게 주어진 API로 데이터를 받아와서 화면을 구성하는 형식이었다.끝까지 막혔던 부분은 데이터를 전역에서 공유하기 위해 context를 사용했는데 ContextProvider에 기본 값으로 줘야할 value 속성을 초기화하는 부분에서 좀 막혔다. 그리고 리액트에서 동적으로 구성한 input 요소들의 유효성 검사도 어떻게 해야할지 고민을 많이 했다.(그래도 예전에 공부해뒀던 코드가 도움이 많이 됐다..)결과적으로 목록 API를 받아와서 화면에 뿌려준 것만 한 거 같다. 바닐라 자바스크립트로만 과제 테스트를 해봤는데 이번에 리액트랑 타입스크립트로 해보니 해결한건 많이 없지만 뭔가 한 단계 업그레이드된 기분이다. 그냥 기분만 그렇다.역시 테스트를 하고 나면 느끼는건 더 열심히 해야겠다는 것,,, 과제 테스트는 나중에 프로그래머스에 올라올지 모르겠지만 생각나는대로 다시 구현해봐야겠다." }, { "title": "📸 2022-09-23", "url": "/posts/220923TIL/", "categories": "TIL", "tags": "타입스크립트", "date": "2022-09-23 22:58:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? TypeScript 함수🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 타입스크립트를 조금 더 공부해보고 읽어보면 좋은 글인거 같다. 올해 버려야 할 타입스크립트 나쁜 버릇 10가지 🌟 내일은 어떻게 해보고 싶으세요? 2023 KAKAO BLIND RECRUITMENT 2022 자비스앤빌런즈 개발자 공개채용 챌린지 - 2차 과제 테스트" }, { "title": "타입스크립트의 심화 - 함수", "url": "/posts/deep-dive-typescript/", "categories": "study", "tags": "타입스크립트", "date": "2022-09-23 18:24:00 +0900", "snippet": " ✍️ Typescript :기초부터 실전형 프로젝트까지 with React + NodeJS 강의를 보면서 정리하는 글함수 반환 타입 명시하기함수의 반환 타입을 지정하는 방법은 아래처럼 함수 우측에 콜론과 반환할 타입을 명시해주면 된다.// 👇 매개변수로 두 개의 숫자를 받아 숫자를 반환하는 함수function add(num1: number, num2: number): number { return num1 + num2;}아무것도 반환하지 않는 함수는 void로 명시해주면 된다.function add(num1: number, num2: number): void { console.log(num1 + num2);}// ✅ 반환 타입을 undefined로 지정할 수도 있는데 이 경우에는 return 문은 존재해야 한다.// 따라서 대다수의 경우에는 void로 반환 값이 없음을 표현한다.function add(num1: number, num2: number): void { console.log(num1 + num2); return; //또는 return undefined;함수 타입을 변수의 타입으로 명시할 수도 있다. Function으로 타입을 명시하면 함수만 할당할 수 있다. 하지만 매개변수와 반환 타입 같은 세세한 설정은 할 수 없어 어떤 함수든 할당될 수 있다.function add(num1: number, num2: number): number { return num1 + num2;}function addString(str1: string, str2: string): string { return str1 + str2;}let combineValues: Function;combineValues = add;combineValues(4, 5); // 9// ⚠️ 문자열을 받아 문자열을 반환하는 함수이지만 함수 타입이기만 하면 할당되고 호출할 수 있기 때문에 타입 체크가 되지 않는다.// 컴파일과 런타임 모두 에러가 발생하지 않는다.combineValues = addString;console.log(combineValues(4, 5)); // 9매개변수와 반환 타입까지 정확한 타입을 명시할 수 있다.// 👇 이 변수는 두 개의 숫자를 매개변수로 받으며 숫자를 반환하는 함수만 할당할 수 있다.let combineValues: (a: number, b: number) =&gt; number;combineValues = add;console.log(combineValues(4, 5));// ⚠️ ERROR!// '(str1: string, str2: string) =&gt; string' 형식은 '(a: number, b: number) =&gt; number' 형식에 할당할 수 없습니다.// 'str1' 및 'a' 매개 변수의 형식이 호환되지 않습니다.// 'number' 형식은 'string' 형식에 할당할 수 없습니다.combineValues = addString; 🐝 참고 타입스크립트에서 함수 문법unknown과 anyany 타입을 쓰면 타입스크립트는 원하는대로 작성하게 해준다. unknown은 any보다 더 제한적이다.let userInput: unknown;let userName: string;// 👇 문자열을 할당해도 unknown 타입이므로 string 타입으로 인식되지 않는다.userInput = \"yeeun\";// ⚠️ ERROR!// 'unknown' 형식은 'string' 형식에 할당할 수 없습니다.userName = userInput;let userInput: any;let userName: string;// 👇 any는 유연한 타입이므로 타입 확인을 수행하지 않는다.userInput = \"yeeun\";userName = userInput;never리턴하지 않는 함수(while(true){})) 또는 항상 예외를 던지는 함수일 때 발생한다.리턴하지 않는다는 것은 아무것도 반환하지 않는 void와는 완전히 다른 값이므로 혼동하지 않도록 해야한다.함수 선언식은 함수를 기본으로 void로 추론하는 반면 함수 표현식은 never로 추론한다. 아무런 타입도 명시하지 않은 함수 선언식 아무런 타입도 명시하지 않은 함수 표현식 never를 명시한 함수 선언식 🐝 참고 Never 타입 👇 아직 이해하기 어려운 글… 나중에 다시 읽어봐야겠다. 타입스크립트의 Never 타입 완벽 가이드" }, { "title": "타입스크립트의 기초 - 타입", "url": "/posts/basic-of-typescript/", "categories": "study", "tags": "타입스크립트", "date": "2022-09-22 19:08:00 +0900", "snippet": " ✍️ Typescript :기초부터 실전형 프로젝트까지 with React + NodeJS 강의를 보면서 정리하는 글JavaScript와 TypeScript 차이 타입스크립트 타입은 컴파일 중에 확인되고 자바스크립트 타입은 런타임 중에 확인된다.자바스크립트는 동적 타입으로 하나의 변수에 문자열도 넣었다가 숫자를 넣어도 문제가 발생하지 않는다. 타입을 체크하거나(typeof) 관련 에러는 런타임 시 확인 가능하다.반면, 타입스크립트는 정적 타입이다. 개발 도중에 타입을 체크하고 관련 에러를 미리 방지할 수 있다. 자바스크립트 엔진에는 타입스트립트의 이런 타입 체크 기능이 내장되어 있지 않기 때문에 타입스크립트를 사용하면 개발 도중에만 지원을 받을 수 있다. 🔖 타입스크립트는 새로 만들어진 언어가 아닌 자바스크립트를 사용해 새로운 기능과 장점을 추가한 언어이다. 자바스크립트를 더 쉽고 강력하게 해준다. 🔖 타입스크립트는 브라우저와 같은 자바스크립트 환경에서 실행할 수 없다. 따라서 타입스크립트로 코드를 작성 후 타입스크립트의 문법들을 자바스크립트 해결책으로 컴파일한다. 🔖 타입을 위한 구문으로 자바스크립트로 컴파일할 때 코드를 평가하고 잠재적 에러를 찾는데 사용되지만 컴파일 후 얻게 되는 자바스크립트 코드에서는 제거된다. 자바스크립트의 문법이 아니기 때문이다. 🔖 타입스크립트는 우리가 의도를 더 명확히 하고 코드를 다시 확인하도록 요구한다. 변수에 값을 할당할 때는 타입을 지정하지 않아도 된다.let number1 = 10;과 같이 변수 선언과 동시에 값을 할당하는 경우 타입 추론(type inference)라는 내장 기능을 활용하여 number라는 변수는 number 타입이라는 것을 알 수 있다. 따라서 타입을 지정하지 않아도 된다.다만 let number1;처럼 변수 선언문만 쓴다면 추후 값을 할당 시 타입 체크를 위해 변수명 우측에 타입을 지정해주는 것이 좋다. (let number1: number;)또한 이미 특정 타입의 값이 할당된 변수에 다른 타입의 값을 재할당하는 경우도 타입스크립트는 에러를 발생시킨다.타입스크립트는 이처럼 타입을 잘못 사용하고 있는지 확인하고 에러를 통해 개발 단계에서 바로 잡을 수 있도록 알려주는 작업을 수행한다.타입스크립트의 튜플과 Enum튜플튜플은 배열의 서브타입이다. 배열과 달리 튜플은 선언 시 길이와 각 인덱스의 타입을 명시해야 한다. 튜플과 배열 모두 대괄호를 사용하기 때문에 튜플의 타입을 명시하지 않는 경우 타입스크립트는 배열로 타입을 추론하게 된다.튜플을 사용하면 배열의 요소의 타입과 개수를 고정할 수 있지만 push() 메서드로 요소를 삽입하여 정해진 길이보다 길어지더라도 오류가 발생하지 않는다.let test: [number, string] = [1, \"second\"];test.push(10);console.log(test); //(3) [1, 'secode', 10]// ⚠️ ERROR!// 길이가 '2'인 튜플 형식 '[number, string]'의 인덱스 '3'에 요소가 없습니다.test[3] = 100;// ⚠️ ERROR!// '[number, string, number]' 형식은 '[number, string]' 형식에 할당할 수 없습니다. 소스에 3개 요소가 있지만, 대상에서 2개만 허용합니다.test = [10, \"repeat\", 30];Enum(열거형)열거형은 해당 타입으로 사용할 수 있는 값을 열거한다.enum 키워드로 enum을 생성하고 이름을 명시해준다. 중괄호 안에 사용할 키 값을 열거해주면 된다. 자동으로 열거형의 각 멤버에 숫자를 추론해서 할당하지만, 값을 명시적으로 설정할 수도 있다.// 👇 멤버에 값을 명시하지 않은 경우 순서대로 0, 1, 2의 값을 가지게 된다.enum Fruit { APPLE, ORANGE, BANANA}console.log(Fruit[0]); // APPLEconsole.log(Fruit.ORANGE); // 1// 👇 각 멤버에 값을 명시해줄 수 있다. 숫자와 문자열을 혼합할 수 있다.enum Fruit { APPLE = 1, ORANGE = 2, BANANA = \"BANANA\"}console.log(Fruit.ORANGE); // 2// 👇 모든 멤버에 값을 명시해줘야 하는 것은 아니다. 빠진 값은 타입스크립트가 추론한다.enum Fruit { APPLE = 3, ORANGE = 100, BANANA}console.log(Fruit.BANANA) /// 101" }, { "title": "📸 2022-09-22", "url": "/posts/220922TIL/", "categories": "TIL", "tags": "타입스크립트", "date": "2022-09-22 13:50:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? TypeScript 기본 &amp; 기본 타입🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 타입스크립트 함수, 클래스, 인터페이스 사용법 알아보기" }, { "title": "📸 2022-09-19", "url": "/posts/220919TIL/", "categories": "TIL", "tags": "리팩터링", "date": "2022-09-19 23:36:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? [📖 리팩터링 2판] Chapter 01 읽고 따라서 코딩하고 수정하기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 리팩터링 p.59에서 반복문을 파이프라인으로 바꾸기를 적용하면서 for 구문을 reduce로 수정한다. 여기서 파이프라인의 정의가 궁금해졌다. Pipe function의 이해와 프로젝트 적용기 참고하기! 🌟 내일은 어떻게 해보고 싶으세요? 파이프라인 개념 이해하기Chapter 01 - 리팩터링 : 첫 번째 예시 🔖 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다. 🔖 리팩터링의 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다. 🔖 하나의 리팩터링을문제없이 끝낼 때마다 커밋한다. 그래야 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 있다. 🔖 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다. 🔖 좋은 코드라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다란 역할을 한다. 🔖 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다. 🔖 지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 🔖 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다. 🔖 간결함이 지혜의 정수일지 몰라도, 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다. 🔖 좋은 코드를 가늠하는 확실한 방법은 ‘얼마나 수정하기 쉬운가‘다. 🔖 리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다. 전체 코드 : https://codesandbox.io/s/refactoring-traning-ptdrrn?file=/src/ch1/createStatementData.js" }, { "title": "📸 2022-09-18", "url": "/posts/220918TIL/", "categories": "TIL", "tags": "코딩테스트", "date": "2022-09-18 21:31:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 2022 자비스앤빌런즈 개발자 공개채용 챌린지 신한DS - 개발 역량 과제 테스트🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? API로 데이터 가져오고 원하는대로 가공하기🌟 내일은 어떻게 해보고 싶으세요?2022 자비스앤빌런즈 개발자 공개채용 챌린지 후기프로그래머스 챌린지에서 공고를 발견해서 지원했다. 프론트엔드 엔지니어로 지원하여 JavaScript로 응시했다. 3시간동안 총 4문제를 해결해야 했고 난 2문제만 성공했다.첫 번째 문제는 주어진 문자열에서 특정 문자열 갯수에 따라 카운트를 측정하는 문제였다. Map과 배열의 반복문을 사용했다.두 번째 문제도 반복문으로 카운트를 세서 최소, 최대값을 구하는 문제였다. 여기서도 Map을 사용했는데 Map에서 value가 Number일 때 최소 최대값을 쉽게 구할 수 있는 방법을 생각하는데 오래 걸렸다. for...of로 모든 key-value를 비교해서 최소, 최대값을 구했다.나머지 문제들은 그림만 봐도 보통이 아니다 싶었다. 위에 2문제를 풀면서 약 2시간이 소요됐고 이후에 일정이 있어 제대로 풀지는 못했다. 나중에 프로그래머스에서 문제를 풀어주면 다시 해봐야겠다.신한 DS 개발 역량 과제 테스트 후기얼떨결에 지원한 뒤에 운좋게 서류가 붙어서 과제 테스트도 응시할 수 있었다. 하나의 과제를 2시간 내에 풀어야 했다.본 테스트 전 데모 테스트를 제공해줬는데 개발 환경과 파일 생성하는 shell 파일들이 익숙하지 않아서 쉽지 않겠다고 생각은 했었지만 본 테스트도 꽤 어려웠다. NodeJS도 가능하다고 했지만 shell 파일이나 sample에 Java가 있어서 Java로 코딩하기로 했다.주어진 API로 데이터를 받아온 후 문제에서 요구하는대로 데이터를 가공 후 지정된 경로에 JSON 파일을 저장해야했다. Java를 안쓴지 너무 오래 돼기도 했고 워낙 다른 소스들을 참고해서 코딩한 기억뿐이라 데이터 불러오는 것도 구글링을 했다. String으로 저장된 데이터를 JSON으로 파싱하려고 했는데 외부 라이브러리를 설치해야 했다. 여기서 막혔다ㅠㅠ VSCode 환경에서 Java를 사용한 적도 처음이고 shell 파일에 설치해야 하는 라이브러리를 작성하라고 했었는데 무슨 말인지 이해가 안됐다. 여기까지 한 시간이 걸렸고 도저히 진전이 없어 포기했다.API로 데이터를 받아오고 데이터를 가공하는 문제는 이전에도 비슷한 문제를 본 기억이 있기 때문에 NodeJS로라도 기본으로 알아둬야겠다는 생각이 들었다." }, { "title": "트리를 순회하는 방법", "url": "/posts/data-structure-tree-search/", "categories": "study", "tags": "자료구조, 이진탐색트리", "date": "2022-09-16 14:56:00 +0900", "snippet": " ✍️ JavaScript 알고리즘 &amp; 자료구조 마스터클래스 강의를 보면서 정리하는 글트리를 탐색하는 방법크게 수평으로 탐색하거나 수직으로 탐색하는 방법으로 나뉜다. 수평으로 탐색하는 방법을 너비 우선 탐색(BFS: Breadth-first Search)이라고 하고 수직으로 탐색하는 방법은 깊이 우선 탐색(DFS: Depth-first Search)이라고 한다.너비 우선 탐색(BFS: Breadth-first Search)배열이나 리스트를 사용해서 선입선출 구조인 큐를 생성하고 방문하는 노드들을 추적한다.의사코드 1️⃣ 루트 노드부터 탐색을 시작하므로 먼저 루트 노드를 큐에 저장한다. 2️⃣ 큐가 비어질 때까지 하위 작업을 반복한다. 2️⃣-1 큐에 저장된 첫 번째 노드(= 큐에 들어온지 가장 오래된 요소)를 제거하면서 자식 노드가 존재하는지 확인한다. 2️⃣-2 왼쪽에서 오른쪽으로 탐색하므로 자식 노드도 왼쪽 노드 확인 후 오른쪽 노드를 확인하여 존재한다면 큐에 저장한다. 구현class BinarySearchTree { constructor() { this.root = null; } BFS() { const queue = []; const visited = []; if (!this.root) return; let current; // 1️⃣ 루트 노드부터 탐색을 시작하므로 먼저 루트 노드를 큐에 저장한다. queue.push(this.root); // 2️⃣ 큐가 비어질 때까지 하위 작업을 반복한다. while (queue.length &gt; 0) { // 2️⃣-1 큐에 저장된 첫 번째 노드(= 큐에 들어온지 가장 오래된 요소)를 제거하면서 자식 노드가 존재하는지 확인한다. current = queue.shift(); visited.push(current.value); // 2️⃣-2 왼쪽에서 오른쪽으로 탐색하므로 자식 노드도 왼쪽 노드 확인 후 오른쪽 노드를 확인하여 존재한다면 큐에 저장한다. if (current.left) { queue.push(current.left); } if (current.right) { queue.push(current.right); } } return visited; }}깊이 우선 탐색(DFS: Depth-first Search)형제 노드를 방문하기 전에 현재 노드에서 탐색할 수 있는 트리의 맨 아래 노드까지 도달한다.PreOrder: 전위 순회먼저 부모 노드 방문 후 왼쪽에 있는 모든 자식 노드들을 모두 순회한 후 오른쪽도 동일하게 순회한다. (부모 -&gt; 왼쪽 자식 -&gt; 오른쪽 자식 순으로 방문)의사코드 1️⃣ 방문했던 노드를 저장할 배열을 생성한다. 2️⃣ 부모 노드 방문 후 자식 노드를 확인하기 때문에 부모 노드의 값을 배열에 저장한다. 3️⃣ 왼쪽 자식 노드가 존재하는지 확인한다. 3️⃣-1 존재하면 트리의 맨 아래 왼쪽 자식 노드까지 탐색하기 위해 해당 함수에 왼쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. 4️⃣ 모든 왼쪽 자식 노드의 순회가 끝나면 오른쪽 자식 노드가 존재하는지 확인한다. 4️⃣-1 존재하면 트리의 맨 아래 오른쪽 자식 노드까지 탐색하기 위해 해당 함수에 오른쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. 구현class BinarySearchTree { constructor() { this.root = null; } DFSPreOrder() { // 1️⃣ 방문했던 노드를 저장할 배열을 생성한다. let visited = []; function traverse(node) { // 2️⃣ 부모 노드 방문 후 자식 노드를 확인하기 때문에 부모 노드의 값을 배열에 저장한다. visited.push(node); // 3️⃣ 왼쪽 자식 노드가 존재하는지 확인한다. if (node.left) { // 3️⃣-1 존재하면 트리의 맨 아래 왼쪽 자식 노드까지 탐색하기 위해 해당 함수에 왼쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. traverse(node.left); } // 4️⃣ 모든 왼쪽 자식 노드의 순회가 끝나면 오른쪽 자식 노드가 존재하는지 확인한다. if (node.right) { // 4️⃣-1 존재하면 트리의 맨 아래 오른쪽 자식 노드까지 탐색하기 위해 해당 함수에 오른쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. traverse(node.right); } } traverse(this.root); return visited; }}전위 순회를 visualgo로 실행해보았다.사진으로 간략하게 표현하면 아래와 같다.PostOrder: 후위 순회부모 노드를 방문하기 전에 모든 자식 노드들을 모두 순회한다. 즉, 왼쪽에 있는 모든 자식 노드들을 모두 순회한 후 오른쪽도 동일하게 순회한 뒤에 부모 노드를 방문한다. (왼쪽 자식 -&gt; 오른쪽 자식-&gt; 부모 순으로 방문)의사코드 1️⃣ 방문했던 노드를 저장할 배열을 생성한다. 2️⃣ 왼쪽 자식 노드가 존재하는지 확인한다. 2️⃣-1 존재하면 트리의 맨 아래 왼쪽 자식 노드까지 탐색하기 위해 해당 함수에 왼쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. 3️⃣ 모든 왼쪽 자식 노드의 순회가 끝나면 오른쪽 자식 노드가 존재하는지 확인한다. 3️⃣-1 존재하면 트리의 맨 아래 오른쪽 자식 노드까지 탐색하기 위해 해당 함수에 오른쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. 4️⃣ 모든 자식 노드 방문 후 부모 노드를 방문하기 때문에 부모 노드의 값을 배열에 저장한다.구현class BinarySearchTree { constructor() { this.root = null; } DFSPostOrder() { // 1️⃣ 방문했던 노드를 저장할 배열을 생성한다. let visited = []; function traverse(node) { // 2️⃣ 왼쪽 자식 노드가 존재하는지 확인한다. if (node.left) { // 2️⃣-1 존재하면 트리의 맨 아래 왼쪽 자식 노드까지 탐색하기 위해 해당 함수에 왼쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. traverse(node.left); } // 3️⃣ 모든 왼쪽 자식 노드의 순회가 끝나면 오른쪽 자식 노드가 존재하는지 확인한다. if (node.right) { // 3️⃣-1 존재하면 트리의 맨 아래 오른쪽 자식 노드까지 탐색하기 위해 해당 함수에 오른쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. traverse(node.right); } // 4️⃣ 부모 노드 방문 후 자식 노드를 확인하기 때문에 부모 노드의 값을 배열에 저장한다. visited.push(node); } traverse(this.root); return visited; }}사진으로 간략하게 표현하면 아래와 같다. 아쉽게도 visualgo에서 후위 순회는 아직 지원하지 않았다ㅠㅠInOrder: 정위 탐색왼쪽에서 오른쪽 방향으로 탐색한다. 즉, 왼쪽에 있는 모든 자식 노드들을 모두 순회한 후 부모 노드를 방문하고 오른쪽 자식 노드들을 순회한다. (왼쪽 자식 -&gt; 부모 -&gt; 오른쪽 자식 순으로 방문)의사코드 1️⃣ 방문했던 노드를 저장할 배열을 생성한다. 2️⃣ 왼쪽 자식 노드가 존재하는지 확인한다. 2️⃣-1 존재하면 트리의 맨 아래 왼쪽 자식 노드까지 탐색하기 위해 해당 함수에 왼쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. 3️⃣ 부모 노드의 값을 배열에 저장한다. 4️⃣ 모든 왼쪽 자식 노드의 순회가 끝나면 오른쪽 자식 노드가 존재하는지 확인한다. 4️⃣-1 존재하면 트리의 맨 아래 오른쪽 자식 노드까지 탐색하기 위해 해당 함수에 오른쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. 구현class BinarySearchTree { constructor() { this.root = null; } DFSInOrder() { // 1️⃣ 방문했던 노드를 저장할 배열을 생성한다. let visited = []; function traverse(node) { // 2️⃣ 왼쪽 자식 노드가 존재하는지 확인한다. if (node.left) { // 2️⃣-1 존재하면 트리의 맨 아래 왼쪽 자식 노드까지 탐색하기 위해 해당 함수에 왼쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. traverse(node.left); } // 3️⃣ 부모 노드의 값을 배열에 저장한다. visited.push(node); // 4️⃣ 모든 왼쪽 자식 노드의 순회가 끝나면 오른쪽 자식 노드가 존재하는지 확인한다. if (node.right) { // 4️⃣-1 존재하면 트리의 맨 아래 오른쪽 자식 노드까지 탐색하기 위해 해당 함수에 오른쪽 자식 노드를 매개변수로 전달하며 재귀 호출한다. traverse(node.right); } } traverse(this.root); return visited; }}정위 순회를 visualgo로 실행해보았다.사진으로 간략하게 표현하면 아래와 같다.언제 무엇을 사용해야 하는가?트리의 모든 노드를 한 번씩 방문해야 하므로 시간 복잡도는 동일하다. 비교해야 하는 것은 공간 복잡도이다.가로로 넓게 퍼진 트리를 너비 우선 탐색으로 순회를 하게 되면 큐에 저장되는 데이터가 많다. 따라서 깊이보다 너비가 넓은 트리의 경우에는 깊이 우선 탐색이 더 적은 공간을 점유한다.반대로 너비보다 깊이가 깊은 트리를 탐색할 때에는 아래로 내려가는 레벨이 많기 때문에 자식 노드를 재귀로 호출하며 호출 스택에서 차지하고 있어 메모리를 많이 차지하게 된다. 깊이가 있는 트리는 너비 우선 탐색을, 너비가 큰 트리는 깊이 우선 탐색으로 순회하는 것이 효율적이다." }, { "title": "📸 2022-09-16", "url": "/posts/220916TIL/", "categories": "TIL", "tags": "자료구조, 이진탐색트리", "date": "2022-09-16 14:56:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 트리를 탐색하는 세 가지 알고리즘🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?" }, { "title": "📸 2022-09-15", "url": "/posts/220915TIL/", "categories": "TIL", "tags": "이진탐색트리", "date": "2022-09-15 18:30:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 이진탐색트리 구현하기 자료구조와 알고리즘을 시각적으로 쉽게 구현해볼 수 있는 사이트 : VisuAlgo🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 이진탐색트리로 해결할 수 있는 문제 풀어보기" }, { "title": "이진 탐색 트리 구현하기", "url": "/posts/data-structure-binarysearchtree/", "categories": "study", "tags": "자료구조, 이진탐색트리", "date": "2022-09-15 14:50:00 +0900", "snippet": " ✍️ JavaScript 알고리즘 &amp; 자료구조 마스터클래스 강의를 보면서 정리하는 글이진 트리각 노드가 최대 2개의 자식 노드만 가질 수 있다.이진 탐색 트리부모 노드의 왼쪽에 있는 모든 노드는 언제나 부모보다 작고 오른쪽에 있는 모든 노드는 언제나 부모보다 크다. 이 규칙으로 인해 이진 트리가 정렬되기 때문에 탐색 작업이 수월하다.구현이진 탐색 트리를 구현하기 위해서는 트리 본체를 위한 클래스와 각 노드를 구성할 클래스가 필요하다.// 👇 노드class Node { constructor(value) { this.value = value; //left와 right는 각각 왼쪽, 오른쪽 자식 노드를 가리킨다. this.left = null; this.right = null; }}// 👇 트리 본체class BinarySearchTree { constructor() { this.root = null; }}트리 객체를 생성하고 루트 노드와 자식 노드들을 설정하자.const tree = new BinarySearchTree();tree.root = new Node(10);// ⭐️ 왼쪽 자식 노드는 부모보다 작은 값을 가져야 한다.tree.root.left = new Node(5);// ⭐️ 오른쪽 자식 노드는 부모보다 큰 값을 가져야 한다.tree.root.right = new Node(20);루트 노드에 left와 right를 초기화 후 루트를 확인해보면 left와 right에 값이 설정되어 있다.⛳️ insert 이진탐색트리에 새로운 값을 추가하기 위한 메서드이다. 부모 노드보다 작으면 왼쪽, 크면 오른쪽에 위치되어야 원칙에 따라 값을 비교하며 알맞은 위치에 추가한다.의사코드 1️⃣ 새로운 노드를 생성한다. 2️⃣ 탐색은 루트에서 시작하므로 우선 루트가 존재하는지 확인한다. 2️⃣-1 존재하지 않으면 새 노드를 루트로 지정한다. 2️⃣-2 존재하면 새 노드의 값이 루트 노드의 값보다 큰지 작은지 비교한다. ⭐️ 새 노드의 값 &lt; 루트 노드의 값 왼쪽 자식 노드가 존재하는지 확인한다. 존재하지 않으면 새 노드를 왼쪽 자식 노드로 추가한다. 존재하면 해당 노드로 이동 후 노드 간 비교 작업을 반복한다. ⭐️ 새 노드의 값 &gt; 루트 노드의 값 오른쪽 자식 노드가 존재하는지 확인한다. 존재하지 않으면 새 노드를 오른쪽 자식 노드로 추가한다. 존재하면 해당 노드로 이동 후 노드 간 비교 작업을 반복한다. 구현class BinarySearchTree { insert(value) { // 1️⃣ 새로운 노드를 생성한다. const newNode = new Node(value); // 2️⃣ 탐색은 루트에서 시작하므로 우선 루트가 존재하는지 확인한다. // 2️⃣-1 존재하지 않으면 새 노드를 루트로 지정한다. if (!this.root) { this.root = newNode; return; } // 2️⃣-2 존재하면 새 노드의 값이 루트 노드의 값보다 큰지 작은지 비교한다. let current = this.root; while (true) { // ⭐️ 새 노드의 값 &lt; 루트 노드의 값 if (value &lt; current.value) { // 왼쪽 자식 노드가 존재하는지 확인한다. if (!current.left) { // 존재하지 않으면 새 노드를 왼쪽 자식 노드로 추가한다. current.left = newNode; return; } // 존재하면 해당 노드로 이동 후 노드 간 비교 작업을 반복한다. current = current.left; } // ⭐️ 새 노드의 값 &gt; 루트 노드의 값 else if (value &gt; current.value) { // 오른쪽 자식 노드가 존재하는지 확인한다. if (!current.right) { // 존재하지 않으면 새 노드를 오른쪽 자식 노드로 추가한다. current.right = newNode; return; } // 존재하면 해당 노드로 이동 후 노드 간 비교 작업을 반복한다. current = current.right; } } }}⚒️ 중복되는 수는 어떻게 처리할 것인가?트리에 존재하는 수가 매개변수로 전달될 때 false나 undefined를 반환하도록 할 수 있다.// 위 코드의 38줄 아래에 추가하면 된다.else{ return false; //return undefined;}또는 Node 클래스에 카운터 속성을 추가해서 같은 값의 수가 몇 번이나 들어오는지 체크해도 된다.🎣 find매개변수로 받은 값이 이진탐색트리에 존재하는지 탐색한다. 루트 노드부터 값을 비교하며 해당 노드를 찾아 노드의 끝으로 이동하기 때문에 insert와 유사하게 동작한다. 반환 값으로 존재 여부(참이나 거짓) 또는 해당 노드를 사용해도 된다.의사코드 0️⃣ 탐색은 루트에서 시작하므로 우선 루트가 존재하는지 확인한다. 1️⃣ 존재하지 않으면 탐색할 노드가 없으므로 탐색 종료 2️⃣ 존재하면 찾고자 하는 값과 루트 노드의 값을 비교한다. 2️⃣-1 찾고자 하는 값 === 루트 노드의 값 : 탐색 종료 2️⃣-2 찾고자 하는 값 !== 루트 노드의 값 : 찾고자 하는 값이 루트 노드의 값보다 큰지 작은지 비교한다. ⭐️ 찾고자 하는 값 &lt; 루트 노트의 값 왼쪽 자식 노드가 존재하는지 확인한다. 존재하지 않으면 탐색 종료 존재하면 해당 노드로 이동 후 탐색 작업을 반복한다. ⭐️ 찾고자 하는 값 &gt; 루트 노트의 값 오른쪽 자식 노드가 존재하는지 확인한다. 존재하지 않으면 탐색 종료 존재하면 해당 노드로 이동 후 탐색 작업을 반복한다. 구현class BinarySearchTree { find(value) { // 0️⃣ 탐색은 루트에서 시작하므로 우선 루트가 존재하는지 확인한다. // 1️⃣ 존재하지 않으면 탐색할 노드가 없으므로 탐색 종료 if (!this.root) { return null; } // 2️⃣ 존재하면 찾고자 하는 값과 루트 노드의 값을 비교한다. let current = this.root; while (true) { // 2️⃣-1 찾고자 하는 값 === 루트 노드의 값 : 탐색 종료 if (value === current.value) { return current; } // 2️⃣-2 찾고자 하는 값 !== 루트 노드의 값 : 찾고자 하는 값이 루트 노드의 값보다 큰지 작은지 비교한다. // ⭐️ 찾고자 하는 값 &lt; 루트 노트의 값 if (value &lt; current.value) { if (!current.left) return null; current = current.left; } // ⭐️ 찾고자 하는 값 &gt; 루트 노트의 값 else { if (!current.right) return null; current = current.right; } } }}⌛️ 시간 복잡도평균적으로 값을 삽입하는 것과 탐색하는 것 모두 O(log n)을 가진다.이진탐색트리의 최악의 경우는 모든 노드의 값이 부모보다 작거나 커서 연결 리스트처럼 한 쪽으로 쏠려 있는 형태이다. 이런 경우에 최대값 또는 최소값을 삽입 또는 탐색할 때에는 O(N)의 시간복잡도를 가진다.한 쪽으로 치우친 트리는 굳이 트리 구조를 사용하지 않아도 된다. 또는 중간 값을 루트 노드로 지정하여 트리를 재구성하여 사용하는 것이 더 효율적이다.마무리 전체 코드 : https://codesandbox.io/s/data-structure-by-javascript-gv68jw?file=/src/binarysearchtree.js" }, { "title": "비선형구조, 트리", "url": "/posts/data-structure-tree/", "categories": "study", "tags": "자료구조", "date": "2022-09-13 19:20:00 +0900", "snippet": " ✍️ JavaScript 알고리즘 &amp; 자료구조 마스터클래스 강의를 보면서 정리하는 글트리는 리스트와 달리 비선형구조이다. 리스트가 기차 구조라면 트리는 나무에 비유할 수 있다. 나뭇가지는 여러 가지들로 뻗어나가는 것처럼 트리는 하나의 요소에 연결된 요소들이 2개 이상일 수 있다. 리스트는 기차의 각 열차처럼 앞뒤로 최대 하나의 요소와 연결할 수 있다.트리의 중요한 특징은 노드 간의 관계는 부모-자식 관계만 성립될 수 있다. 즉, 하나의 노드가 여러 개의 자식 노드를 가질 수 있지만 형제 노드와는 연결될 수 없다.(형제 노드 간 연결된 구조는 그래프이다.) 또한 자식 노드는 부모 노드를 가리킬 수 없다. 트리에서 모든 노드는 루트에서 멀어지는 방식(아래쪽으로 향한다.)으로 연결된다. 그리고 이 루트는 트리의 시작점이며 반드시 하나여야 한다.실생활에서 사용되는 트리의 개념HTML DOMHTML은 여러 요소들로 구성되어 있고, 한 요소 안에 다른 요소가 중첩되어 있다. 브라우저는 이 HTML 파일을 읽어 DOM을 생성한다. HTML은 단순 텍스트로 구성되지만 브라우저는 이를 객체 모델로 변환한다. DOM의 구조는 최상단 요소인 &lt;html&gt;을 시작으로 자식 요소들이 중첩되어 있다. 개발자 도구의 Elements 탭에서 DOM과 가장 유사한 형태의 트리 구조를 확인할 수 있다. DOM 자체가 아닌 유사한 형태라고 한 이유는 개발자 도구가 제공하는 트리 형태의 DOM 객체에는 가상 요소가 포함되기 때문이다. 이와 관련된 내용은 아래 포스트를 참고하자. 🐝 참고 (번역) DOM은 정확히 무엇일까?컴퓨터 폴더 구조컴퓨터의 파일 저장 구조를 보면 폴더 안에 또 다른 폴더 또는 파일이 존재하고, 폴더 내 자식 폴더를 생성할 수 있다.JSONJSON의 데이터 구성은 한 개의 노드 값을 가지고 있는 parent Object에 자식 노드값들로 구성되어 있다." }, { "title": "🍊 2022-08-31", "url": "/posts/220831TIL/", "categories": "TIL", "tags": "CSS", "date": "2022-08-31 17:03:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? transition과 transform 사용하기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?" }, { "title": "transition과 transform 사용하기", "url": "/posts/css-transition-and-transform/", "categories": "study", "tags": "CSS", "date": "2022-08-31 15:23:00 +0900", "snippet": "CSS Transitions and Transforms for Beginnerstransforms는 요소의 모양을 이동하거나 변경하고, transitions는 요소를 부드럽고 점진적으로 현재와는 다른 상태로 바꿔준다.transitionstransitions없이 요소의 모양이 변경하면 하나의 상태에서 다른 상태로 불쑥 변경된다. transitions을 사용함으로써 더 유연하게, 자연스럽게 변화하도록 제어할 수 있다.즉, transitions 속성을 사용하면 요소의 형태가 변하는 과정을 확인할 수 있다.transforms뿐만 아니라 요소의 형태가 변하는 스타일 속성에서 다양하게 사용할 수 있다.(width가 변하거나 color가 변하는 경우)width의 기본 값인 auto일 때에는 애니메이션이 적용되지 않으므로 숫자 값으로 설정해줘야 한다.transitions를 설정하기 위해서 사용해야 하는 필수 속성은 2가지가 있따. transition-property transition-durationtransition의 속성을 각각 정의할 수도 있지만 깔끔한 코드를 위해 축약해서 사용하는 것을 권장한다.div { transition: [property] [duration] [timing-function] [delay];}transition-property (required)애니메이션을 적용시킬 속성을 지정한다.div { /* 👇 transition을 background-color에만 적용하고 싶다면 */ transition-property: background-color; /* 👇 transition을 모든 속성에 적용하고 싶다면 */ transition-property: all;}transition-duration (required)애니메이션을 지속시킬 시간을 지정한다. 모든 속성에 적용할 시간을 명시하거나, 각 속성이 각자 다른 주기를 갖도록 시간을 명시할 수도 있다..div { /* 👇 transition을 300밀리 초만큼 지속 */ transition-duration: 300ms; /* 👇 transition을 1초만큼 지속 */ transition: all 1s; /* 👇 transition을 2초만큼 지속 */ transition: all 2s;}transition-timing (optional)애니메이션의 속도를 지정한다. 기본 값은 ease로 점차 빨라지다가 끝날 쯤에 속도를 늦춘다. 다른 옵션으로 linear, ease, ease-in, ease-out, ease-in-out가 있다. 🐝 참고 timing의 옵션별 예시div { transition-timing-function: ease-in-out;}div { transition: all 3s ease-in-out;}transition-delay (optional)애니메이션의 시작을 지연시킬 수 있다. 기본적으로 transition은 트리거되는 즉시 시작되는데 이를 트리거된 시점 후에 동작시키고 싶다면 delay 속성을 지정하면 된다.div { transition: all 3s 1s;}transforms지금까지 요소의 변화 과정을 자연스럽고 부드럽게 보여줄 수 있는 방법에 대해 알아보았다. 이제 하나의 상태에서 다른 상태로 요소를 변화시킬 수 있는 transform에 대해 알아보자.transform을 사용하여 요소를 회전, 이동, 기울이기 및 크기 조정할 수 있다. 마우스를 올리거나 클릭하는 것과 같이 요소가 상태를 변경할 때 transform이 트리거된다.scale요소의 크기를 늘리거나 줄일 수 있다. 예를 들어 2라는 값은 요소의 기본 크기를 2배를 키우고 0.5는 절반으로 줄인다.가로, 세로에 대한 파라미터를 각각 설정해서 크기를 조정할 수 있다. 예를 들면, transform: scaleX(2)와 같이 쓴다.아니면 scale()로 한번에 가로와 세로를 동일한 비율로 키울 수도 있다. transform: scale(2)로 지정하면 가로, 세로가 2배씩 커지고 scale()에 각각 파라미터를 전달해줘도 된다 : transform: scale(2, 4)rotate요소가 지정된 각도만큼 시계 방향 또는 반시계 방향으로 회전한다. 90deg라는 값은 요소를 시계 방향으로 90도 회전시키고 -90deg는 반시계 방향으로 90도 회전시킨다.360 이상의 숫자로 전체 회전 이상을 표현할 수도 있다. 1080deg는 전체 회전을 3회 반복한다.translate요소를 왼쪽/오른쪽 또는 위/아래로 이동시킨다. 이는 X(수평) Y(수직) 축에 대해 지정된 파라미터를 기반으로 한다.X값으로 양수를 전달하면 오른쪽으로 이동하고 음수를 전달하면 왼쪽으로 이동한다.Y값도 양수를 전달하면 요소를 아래쪽으로 이동하고 음수를 전달하면 위로 이동한다.예를 들어, 오른쪽으로 20px, 아래쪽으로 30px를 이동시키고 싶다면 transform: translate(20px, 30px)이다.skewX축과 Y축에 대해 주어진 값을 기준으로 한 방향으로 비틀거나 기울인다.X값으로 양수를 전달하면 왼쪽으로 기울어지고 음수를 전달하면 오른쪽으로 기울어진다.Y값도 양수를 전달하면 요소를 아래로 기울이고 음수를 전달하면 위로 기울인다.div { /* 👇 왼쪽으로 25도 기울임 */ transform: skewX(25deg); /* 👇 아래로 10도 기울임 */ transform: skewY(10deg); /* 👇 왼쪽으로 25도, 아래로 10도 기울임 */ transform: skew(25deg, 10deg);} ⚠️ skew는 자식 요소들까지 같이 적용된다. 자식 요소들은 원래 각도를 유지하고 싶다면 skew를 반대 값으로(부모 요소에 양수 값이 적용되었다면 음수를, 음수 값이 적용되었다면 양수 값을 전달) 사용하여 조절하면 된다.transform-origintransform-origin은 transform과 별개의 속성이지만 함께 동작한다.이는 회전 중심(원점, 기준점)을 지정한다. 기본값은 요소의 중심점이다.속성 값은 백분율(%)과 키워드(left, top, center, right, bottom) 중 하나로 지정할 수 있다.예를 들어, transform: rotate로 요소를 회전시키려고 하는데 왼쪽 상단을 기준으로 회전시키고자 하면 0% 0%나 left top로 오른쪽 하단을 기준으로 회전시키려면 0% 100% 또는 right bottom로 정해주면 된다.div { /* 👇 transform-origin 속성은 hover selector가 아닌 기본 요소의 스타일 속성으로 적용해줘야 한다. */ transform-origin: left top; transition: transform 1s;}div:hover { transform: rotate(720deg);} 🐝 참고 CSS Transitions and Transforms for Beginners" }, { "title": "🍊 2022-08-30", "url": "/posts/220830TIL/", "categories": "TIL", "tags": "CSS", "date": "2022-08-30 15:00:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? CSS 레이아웃 정리 인터랙티브 웹 개발 제대로 시작하기 강의를 듣다가 CSS의 display와 position에 대해 정리가 필요하여 드림코딩의 CSS 레이아웃 정리 영상을 참고하였다. 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? CSS를 게임으로 공부할 수 있는 사이트🌟 내일은 어떻게 해보고 싶으세요? CSS transform 속성 정리하기 인터랙티브 웹 개발 제대로 시작하기 강의 듣기CSS 레이아웃 정리하기 !important : cascading된 스타일을 모두 무시하고 해당 속성을 준 스타일이 강제 적용된다. 꼭 필요한 경우가 아니라면 사용하지말자. display 속성 inline : block 요소를 inline 요소처럼 사용할 수 있게 내부 컨텐츠에만 스타일을 적용한다. inline-block : 내부 컨텐츠의 크기와 상관없이 block 요소를 한 줄안에 표현할 수 있도록 한다. block : inline 요소를 block 요소처럼 하나의 요소가 한 줄을 차지하게 한다. position 속성 기본 값으로 static을 가진다. top, left, bottom, right 속성값이 무시된다. relative : 원래 위치를 기준으로 배치된다. absolute : 자기 자신이 아닌 상위 요소를 기준으로 배치된다. DOM 트리를 타고 올라가다가 position이 static이 아닌 가장 가까운 상위 요소를 기준으로 한다.(position이 static이 아닌 요소가 없으면 &lt;body&gt; 요소를 기준으로 한다.) 보통은 부모 요소를 relative로 지정한다. fixed : 배치 기준이 브라우저 화면이 된다. sticky : 평소에는 static과 같지만 스크롤 위치가 임계점에 이르면 fixed와 같이 화면에 고정할 수 있다. 🐝 참고 CSS의 position 속성으로 HTML 요소 배치하기 CSS { position: sticky }" }, { "title": "🍊 2022-08-29", "url": "/posts/220829TIL/", "categories": "TIL", "tags": "", "date": "2022-08-29 22:54:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 개발을 시작한 당신에게 해주고 싶은 이야기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?🐣 개발을 시작한 당신에게 해주고 싶은 이야기개발을 시작하는 단계는 아니지만 지금이라도 알아두기 좋은 내용이다.🔖 나 자신을 아는 것은 시간을 절약하고 목표에 더 가까워진다. 내가 만들게 싶은게 무엇인지, 그를 위해서 배워야 하는게 무엇인지 생각해보자.🔖 소프트웨어 개발에는 많은 분야가 있어서 모든걸 다 배우기엔 불가능하다. 그저 신기술이라고 해서 또는 사람들이 많이 쓴다는 이유로 여러 기술을 배워보자고 욕심내지말고 하나의 언어를 전문화하기 위해 노력하자. 하나만 깊게 알아둔다면 다른 언어를 배우는 데 수월하다.🔖 데이터 구조 또는 알고리즘 공부를 미루지 말자.🔖 SQL을 배우자 무슨 언어로 개발하든 데이터베이스와 작업을 해야하고 그러려면 SQL을 알고 있어야 한다.🔖 배울 것이 없다고 자만하지 말고 훌륭한 프로그래머가 되고 싶다면, 항상 학생으로 남자🔖 It is adapt or die🍊 JEJU.log오랜만에 해변 도로 산책한 날!내 제주 바다 픽은 💖세화💖와 💖함덕💖,," }, { "title": "🍊 2022-08-27", "url": "/posts/220827TIL/", "categories": "TIL", "tags": "클린코드, 코딩테스트", "date": "2022-08-27 12:45:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 클린코드 자바스크립트 타입 다루기 경계 다루기 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? isNaN과 Number.isNaN의 차이점🌟 내일은 어떻게 해보고 싶으세요?⛑ 값을 비교할 때는 엄격하게!이제는 값을 비교하는 구문을 작성할 때 무조건 일치 연산자(===)를 사용하지만 예전에는(내가 근무하던 회사에서는) 동등 연산자(==)만 사용했다. \"1\" == 1은 true처럼 타입이 다른 값들도 쉽게 비교가 가능하기 때문에 사용하지만 생각하지 못한 오류를 발생시킬 수 있으므로 엄격한 일치 연산자를 사용하여야 한다. 🐝 동등 연산자와 일치 연산자의 반환 값을 한 눈에 알 수 있는 사이트valueAsNumbertype=\"number\"인 input 요소의 value를 Number 타입으로 형 변환해주므로 parseInt나 Number를 사용해 따로 변환하지 않아도 된다.⚠️ type이 number가 아니면 NaN을 반환하므로 주의하자! 🐝 참고 Input valueAsNumber⛑ 경계값의 포함여부최소값과 최대값 또는 두 개의 파라미터로 범위를 정하는 경우 해당 값을 포함하는지 아닌지에 대한 기준을 정해야 한다. (포함하는지 여부에 따라 포함한다면 이상과 이하, 포함하지 않는다면 초과와 미만) 팀원간의 컨벤션을 정의하거나 네이밍에 의미를 부여하자." }, { "title": "🍊 2022-08-26", "url": "/posts/220826TIL/", "categories": "TIL", "tags": "클린코드, 코딩테스트", "date": "2022-08-26 23:01:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 백준 생태학 - Javascript [클린코드 자바스크립트] 변수 다루기 강의🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요?🙅🏻‍♀️ 전역 변수와 임시 변수를 지양하자프로그램 전역에 변수를 선언하면 window(또는 global)의 객체로 생성되며 그 변수를 선언한 파일 밖에서도 접근이 가능하여 위험하다.특정 함수 내에서 임시변수를 사용하면 코드가 길어지거나 복잡해진다. 함수는 하나의 역할만을 해야한다는 클린코드 규칙에 위배되지 않도록 하나의 역할하는 함수로 분리하고 계산 후 바로 반환하자.나는 함수 내에서 임시 변수를 자주 사용했다. 이유는 가독성을 위함이다. 늘 임시 변수에 계산식을 할당한 뒤에 필요한 곳에서 호출할지, 그 위치에 바로 계산식을 작성할지 고민을 하다가 임시 변수를 생성해서 계산 후 그 변수를 호출하였다.함수 내 임시변수도 그 함수 내에서의 전역 변수이고 다른 개발자가 그 변수를 건드려 함수가 내 의도와 달라질 수 있다는 것을 생각하며 잘 생각해서 임시 변수를 활용하자!" }, { "title": "🏄🏻‍♀️ [자바스크립트] 생태학", "url": "/posts/baekjoon-4358/", "categories": "코딩테스트", "tags": "코테, 백준", "date": "2022-08-26 14:03:00 +0900", "snippet": "📄 문제실버Ⅱ 생태학구현해야 하는 것은파라미터로 전달받은 1️⃣목록을 오름차순으로 정렬하고 2️⃣정렬된 목록을 순회하며 해당 요소의 입력 횟수를 Map에 업데이트한다.2️⃣의 작업이 완료되면 해당 Map을 반복시키며 입력 값 목록에서 각각의 나무가 차지하는 비율을 계산하여 출력한다.🏹 시도const fs = require(\"fs\");const inputs = fs.readFileSync(\"dev/stdin\").toString().trim().split(\"\\n\");//1️⃣목록을 오름차순으로 정렬한다.const orderedInputs = inputs.sort();const totalCount = orderedInputs.length;//2️⃣-1 나무별 차지 비율을 저장하기 위한 Map 변수 생성const dictionary = new Map();//2️⃣-2 정렬된 목록을 순회하며 해당 요소의 입력 횟수를 업데이트한다.orderedInputs.forEach((input) =&gt; dictionary.set(input, (dictionary.get(input) || 0) + 1));//3️⃣ 2️⃣의 작업으로 Map 변수인 dictionary에는 나무별 입력 횟수가 저장되어 있으므로 백분율을 구하여 출력한다.// 백분율은 소수점 네번째 자리까지 반올림 해야 하므로 toFixed 메서드를 사용한다.const result = [];for (let [key, value] of dictionary) { result.push(`${key} ${((value / totalCount) * 100).toFixed(4)}`);}console.log(result.join(\"\\n\"));" }, { "title": "🍊 2022-08-23", "url": "/posts/220823TIL/", "categories": "TIL", "tags": "클린코드", "date": "2022-08-23 11:56:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 📄 프로그래머스 이력서 정리 하반기 데브 매칭에 지원하기 위해서 상반기에 대충..써두었던 이력서 재정비 이력서를 작성하려고 개발 경력을 정리하다보면 나 진짜 열심히 살았다 싶은데 왜 적을만한건 없을까🤔…" }, { "title": "🍊 2022-08-22", "url": "/posts/220822TIL/", "categories": "TIL", "tags": "클린코드", "date": "2022-08-22 17:56:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? [클린코드 자바스크립트] 변수 다루기 강의 ⚠️ 우선 Obsidian에 강의 내용 정리하기 🎬자바스크립트 20년차 개발자처럼 주석다는 법 JSDoc 기능 사용하기 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 몽키 패치가 무엇인가 런타임 환경에서 프로그램의 특정 기능을 수정하여 사용하는 기법 자바스크립트에서 타입이 동적으로 형변환되는 현상 🐝 참고[개발지식] 몽키 패치(Monkey patch)에 대하여 What is Monkey patch? 🌟 내일은 어떻게 해보고 싶으세요? 코딩 테스트 연습하기" }, { "title": "🍊 2022-08-16", "url": "/posts/220816TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-08-16 16:56:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? react의 에러 경계🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? componentDidCatch에서 setState로 상태를 업데이트하고 에러 발생 시 대체 UI 렌더링을 제어할 수 있지만 이런 방식은 이후의 릴리즈에서는 사용할 수 없게 될 것이므로 static getDerivedStateFromError()를 대신 사용하여야 한다 🐝 참고에러 경계(Error Boundaries)) 클래스 컴포넌트 에러 경계(Error Boundaries) 🔖 자바스크립트에서 에러 처리는 try-catch를 사용하면 되는데 리액트의 JSX 문법에서는 사용할 수 없다. 🔖 에러 경계는 하위 컴포넌트 중 하나가 오류를 만들거나 전달할 때 발동한다. 🔖 에러는 렌더링 도중 생명주기 메서드 및 그 아래에 있는 전체 트리에서 잡아낸다. 🔖 에러 경계를 사용하는 이유는 에러가 발생하더라도 애플리케이션 전체의 작동이 중단되지 않고 오류를 처리하기 위해서다. 🔖 함수형 컴포넌트에서는 아직 사용이 불가하여 클래스 컴포넌트를 사용해야 한다.class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false, }; } componentDidCatch(error) { this.setState({ hasError: true }); } render() { return this.state.hasError ? ( &lt;p&gt;Something went wrong.&lt;/p&gt; ) : ( this.props.children ); }}export default ErrorBoundary;🍊 JEJU.log⛰ 단시간에 고강도 운동을 원한다면 성산일출봉 올라가기숙소에서 성산까지 가는 길이 너무 고되었다. 버스를 두 번이나 놓쳐서 한 시간을 날렸고 성산 도착까지 한시간 반 정도가 걸렸다. 도착해서 성산 일출봉을 보는데 감탄이 나오긴 했다. 사진으로 본 것보다 크고 예뻤다. 정상까지 올라가는 길은 생각보다 힘들거라는 조언대로 짧지만 강한 코스였다. 아쉬운건 정상에서 찍은 사진은 실물을 전혀 담지 못한다ㅠㅠ 그건 눈으로 봐야한다.🖼 기대보다 훨씬 좋았던 빛의 벙커" }, { "title": "🍊 2022-08-11", "url": "/posts/220811TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-08-11 23:56:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? react의 클래스 기반 컴포넌트 생명주기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? componentDidUpdate에서 this.setState를 호출하면 무한 루프 발생! 따라서 조건문을 사용해서 무한 루프를 방지해줘야 한다.🌟 내일은 어떻게 해보고 싶으세요?클래스 기반 컴포넌트 생명주기 componentDidMount 컴포넌트가 마운트된 직후에 호출된다. 컴포넌트가 평가되고 DOM에 렌더링되는 시점useEffect를 사용하는 것과 같다.useEffect에 빈 의존성 배열을 전달하면 컴포넌트가 처음 렌더링되는 시점에만 호출된다. 이는 componentDidMount과 같은 역할을 수행하는 것이다. componentDidUpdate 컴포넌트가 갱신되면 호출, 의존성 배열이 있는 useEffect와 동일 의존성 배열처럼 특정 값이 갱신되었을 때에만 상태 값을 갱신하여야 한다. 그렇지 않으면 무한 루프가 발생한다. 인자로 (이전 props, 이전 state)를 전달해주기 때문에 이를 이용해서 조건문을 사용하면 된다. //👇 클래스 기반 컴포넌트class User extends React.Component { constructor(props) { super(props); this.state = { filteredUsers: DUMMY_USERS, searchTerm: \"\", }; } componentDidUpdate(prevProps, prevState) { // 상태 값이 변경되었을 때에만 setState로 갱신한다. if (prevState.searchTerm !== this.state.searchTerm) { this.setState({ filteredUsers: DUMMY_USERS.filter((user) =&gt; user.name.includes(this.state.searchTerm) ), }); } }}// 👇 함수형 컴포넌트const User = (props) =&gt; { const [filteredUsers, setFilteredUsers] = useState(DUMMY_USERS); const [searchTerm, setSearchTerm] = useState(\"\"); useEffect(() =&gt; { setFilteredUsers( DUMMY_USERS.filter((user) =&gt; user.name.includes(searchTerm)) ); }, [searchTerm]);}; componentWillUnmount 컴포넌트가 DOM에서 삭제되기 직전에 호출되며 useEffect의 cleanup과 동일 🍊 JEJU.log🏃🏻‍♀️ 김녕에서 월정까지 해안도로 걸어가기 (뚜벅이란..)한 시간 정도면 껌이라고 생각해서 경치 구경할겸 해안 도로(올레 20번 코스 중간)를 걸어봤다. 쉬울줄 알았는데 제주는 날이 너무 너무 더워서 정말이지 너무 힘들었다. 선크림도 안발라서 얼굴이며 팔이며 다 빨갛게 되고 땀을 뻘뻘 흘렸다. 왜 아무도 안걸어가는지 알 거 같았다.. 그래도 날이 맑아서 바다가 너무 예뻤다." }, { "title": "🍊 2022-08-09", "url": "/posts/220809TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-08-09 22:47:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? react의 클래스 기반 컴포넌트🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? constructor에서 this를 사용하려면 this를 사용하는 구문보다 먼저 super 메서드를 호출해야 한다. 이는 자바스크립트의 규칙이고 super는 곧 부모 클래스, 즉 상속받고 있는 클래스를 의미한다. 클래스 기반 컴포넌트는 React의 Component가 부모 클래스이다. super 메서드에 매개변수로 props를 전달하지 않아도 리액트는 props를 세팅해준다. 생성자 함수 내에서 this.props를 사용해야 한다면 super(props)로 props를 초기화해줘야 한다. 🌟 내일은 어떻게 해보고 싶으세요? react의 클래스 기반 컴포넌트 생명주기 알아보기컴포넌트를 구축하는 또다른 방법 : 클래스 컴포넌트기본적인 사용법 🔖 자바스크립트의 기본 기능인 클래스를 이용하여 컴포넌트를 생성한다. 🔖 최근의 기본값은 함수형 컴포넌트로 구성되지만 리액트 16.8이전에는 state와 side effect를 관리하기 위해서는 클래스 기반 컴포넌트를 사용해야 했다. 🔖 리액트 16.8에서 리액트 훅이라는 개념이 도입되어 클래스 기반에서만 관리할 수 있었던 state와 side effect를 함수형 컴포넌트에서 사용할 수 있게 된다. 훅이라는건 클래스 기반에서는 사용할 수 없다. 🔖 React.Component render()메서드에서 화면에 렌더링하고 싶은 JSX를 반환하면 된다. 함수형 컴포넌트에서의 반환문과 동일하다. props는 매개변수로 받지 않고 this.props로 호출한다. 이는 React의 Component를 상속받았기 때문에 가능하다.// 같은 화면을 렌더링하는 두 가지 방법//👇 클래스 기반 컴포넌트class User extends React.Component { render() { return &lt;div&gt;User Name : {this.props.name}&lt;/div&gt;; }}// 👇 함수형 컴포넌트const User = (props) =&gt; { return &lt;div&gt;User Name : {props.name}&lt;/div&gt;;};state와 이벤트 🔖 state를 정의할 때는 클래스의 생성자(constructor(){})에서 초기화한다. 클래스가 constructor를 정의하고 다른 클래스를 상속 받으면 super()를 통해 상의 클래스의 생성자를 호출해야 한다. 🔖 상태를 변경하고자 할 때는 this.setState() 메서드를 사용한다. 새로운 상태를 매개변수로 전달하며 현재 존재하는 상태와 새로 전달된 객체(또는 갱신 함수가 반환하는 객체)를 병합한다. class User extends React.Component { constructor() { //this를 사용하기 전 super를 호출하지 않으면 오류가 발생한다. super(); //클래스 컴포넌트의 상태는 객체 형태여야 한다. this.state = { showName: true, name: \"yeeunkim\" }; } changeUserName() { this.setState((prev) =&gt; ({ showName: !prev.showName })); } render() { return ( &lt;&gt; {this.state.showName &amp;&amp; &lt;div&gt;User.name : {this.state.name} &lt;/div&gt;} &lt;button onClick={this.changeUserName.bind(this)}&gt; toggle show username &lt;/button&gt; &lt;/&gt; ); }} 🤔 constructor에서 super를 사용해야 하는 이유는? Class &amp; State에서 Constructor와 Super를 쓰는 이유 Dan Abramov - 왜 super(props) 를 명시해 줘야 하는가? 이 블로그에서 말하듯 클래스 필드를 사용해서 state 변수를 선언하면 constructor 내부에서 상태 값을 초기화하지 않아도 된다. 🤔 super에 props를 반드시 넘겨줘야 하는가? super()와 super(props)의 차이" }, { "title": "🍊 2022-08-08", "url": "/posts/220808TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-08-08 23:11:00 +0900", "snippet": "🌟 내일은 어떻게 해보고 싶으세요? 그동안 못했던 리액트 강의 계속 수강하고 코딩테스트도 풀어보기 리팩토링 2판 책 보러 가기 Dev Event에서 구름톤를 알려줬는데 뭔지 찾아보고 지원해봐야겠다🍊 JEJU.log✈️ 새로운 한 달의 시작드디어 제주에 왔다. 여기도 덥기는 마찬가지🥵무료 수화물이 15kg인데 짐을 빼도 빼도 너무 무거워서 집에서 나오기 전까지 계속 정리하다가 나왔다. 눈 앞에서 307번을 놓쳐서 늦으면 어쩌나 걱정했는데 다행히(🤔?) 지연됐었다.부산에서 제주는 정말 가까웠고 공항에서 숙소까지도 가까워서 다행이다. 아직까지는 숙소 대만족이다. (방음은 안되지만…)계획대로 될지는 모르겠지만 한 달동안 여행과 공부 모두 알차게 해야지!🐬" }, { "title": "📸 2022-08-03", "url": "/posts/220803TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-08-03 14:11:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React의 state 스케줄링과 useMemo 자바스크립트의 클로저🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? useMemo와 클로저 다시 정리하기자바스크립트 클로저🔖 함수를 만들고 그 함수 내부의 코드가 탐색하는 스코프를 함수 생성 당시의 렉시컬 스코프로 고정하면 바로 클로저가 되는 것이다.🔖 개념적으로 자바스크립트의 모든 함수는 클로저이지만, 내부 함수가 포함된 함수(여기서는 outer)의 외부에서 내부 함수(여기서는 inner)를 호출하여 외부 함수의 스코프를 참조하면 클로저라고 한다.const outer(param){ const outerParam = `outer : ${param}`; const inner(){ console.log(outerParam); } return inner;}//outer는 inner함수를 반환한다.const closure = outer(\"CLOSURE\");//inner 함수가 생성된 outer 함수의 실행이 종료되었어도 inner는 outer의 스코프에 접근할 수 있다.closure(); //outer : CLOSURE 🐝 참고 Javascript Closure? 클로저? 그리고 클로저 사용해 module을 만들기! 자바스크립트의 스코프와 클로저" }, { "title": "📸 2022-08-02", "url": "/posts/220802TIL/", "categories": "TIL", "tags": "REACT, 코딩테스트", "date": "2022-08-02 23:11:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 프로그래머스 신고 결과 받기 - Javascript React의 memo와 useCallback🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? useCallback의 의존성 더 공부해보기.. 함수를 변경할 경우는 언제이고 의존성 배열에 뭘 추가해야 하는거지..? 오랜만에 코딩테스트해서 그런가, 저 문제만 3번을 풀었는데 풀 때마다 시간이 오래 걸리고 불필요한 반복문을 쓰게 된다. 노력하자..😢🌟 내일은 어떻게 해보고 싶으세요? 코딩 테스트 문제 1개 이상 풀기 React의 useCallback 더 공부하고 써보기React.memo와 useCallback 컴포넌트의 props, state, context가 변경되면 그 컴포넌트 함수를 재실행하며 화면에 나타날 것을 확인한다. 부모 컴포넌트가 위와 같은 이유로 재실행된다면 자식 컴포넌트도 재실행된다. 자식 컴포넌트의 props 값이 변하지 않더라도 재실행된다. 컴포넌트가 재실행된다고 해서 실제 DOM이 업데이트 되는 것은 아니다. 리액트 DOM은 갱신 전후의 상태 차이를 인식하고 실제 DOM에 변화된 부분만 조작한다. React.memo는 인자로 들어간 컴포넌트에 어떤 props가 입력되는지 확인하고 입력되는 모든 props의 신규 값을 확인한 뒤 기존 props와 비교한다. 그리고 props가 바뀐 경우에만 컴포넌트를 재실행 및 재평가한다. props가 변하지 않는 경우 불필요한 렌더링을 방지해주므로 최적화에 도움이 된다. 그런데 왜 전체적으로 사용하지 않을까? memo를 사용하는 것에도 비용이 발생한다. 기존 값과 신규 값을 비교해야 하므로 기존 값을 저장할 공간과 비교 작업을 수행하기 때문이다. 따라서 앱의 크기나 기능에 따라 사용 여부를 적절하게 고려해야 한다. memo로 감싼 컴포넌트에 참조 타입을 props로 전달하면 그 값이 동일하더라도 재실행된다.아래 코드에서 Button은 onClick이라는 props로 함수를 전달 받는다. onClickHandler는 App 내부에서 선언되었기 때문에 App이 다시 렌더링될 때마다 새롭게 생성되어 매번 기존 props와 다른 값으로 인식된다. {} === {}는 false와 같다. const Button = React.memo((props) =&gt; { return &lt;button onClick={props.onClick}&gt;{props.children}&lt;/button&gt;;});const App = () =&gt; { const onClickHandler = () =&gt; { /* ... */ }; return &lt;Button onClick={onClickHandler}&gt;Click!&lt;/Button&gt;;}; 참조 타입의 데이터를 props로 전달하면서 재실행을 방지하려면 useCallback을 사용해야 한다. 특정 객체를 useCallback으로 감싸면 그 객체는 컴포넌트가 재실행될 때 재사용하게 된다. 객체가 변경되어야 할 시점은 의존성을 추가해서 알려줄 수 있다. const onClickHandler = useCallback(() =&gt; { /* ... */}, []); " }, { "title": "🏄🏻‍♀️ [자바스크립트] 신고 결과 받기", "url": "/posts/programmers-92334/", "categories": "코딩테스트", "tags": "코테, 프로그래머스", "date": "2022-08-02 13:31:00 +0900", "snippet": "📄 문제프로그래머스 2022 KAKAO BLIND RECRUITMENT 신고 결과 받기구현해야 하는 것은파라미터로 전달받은 전체 신고 목록(report)에서 1️⃣유저별로 본인이 신고한 기록을 저장하고 2️⃣각 유저가 신고당한 횟수를 각각 기록해둔다.게시판 이용 정지 횟수(k)에 부합하는 이용자들을 확인하고 유저별로 신고한 기록이 담긴 객체에서 이용 정지 대상자가 있다면 메일 전송 횟수를 증가시키고 이를 새 배열에 저장 후 반환한다.🏹 시도function solution(id_list, report, k) { //1️⃣유저별로 본인이 신고한 기록을 저장할 객체 let users = {}; //2️⃣각 유저가 신고당한 횟수를 저장할 객체 let reportCount = {}; //신고 목록은 중복을 허용하지 않으므로 Set 객체를 사용하였다. id_list.forEach((id) =&gt; { users[id] = new Set(); }); //전체 신고 목록을 반복해서 유저별 신고 기록을 업데이트 report.forEach((r) =&gt; { //id : 신고한 사람, reported : 신고당한 사람 const [id, reported] = r.split(\" \"); //동일한 유저를 신고한 기록이 있는지 체크 if (!users[id].has(reported)) { //신고 기록이 없으면 신고 기록에 추가하고 신고당한 유저의 신고 횟수를 증가시킨다. users[id].add(reported); reportCount[reported] = (reportCount[reported] || 0) + 1; } }); return Object.keys(users).map((key) =&gt; { const current = users[key]; let count = 0; //유저별 신고 기록에서 게시판 이용 정지 대상에 부합하는 유저가 있으면 count를 증가 for (let r of current) { if (reportCount[r] &gt;= k) { count++; } } return count; });}⛳️ 더 좋은 해결책프로그래머스 다른 사람의 풀이에서 가장 많은 좋아요를 받은 코드이다. 중복된 신고 목록은 한 건으로 처리되니까 report의 중복을 제거 후 다른 로직을 구현하였다. 중복 제거는 Set을 썼고function solution(id_list, report, k) { //중복 제거를 위해 Set을 사용하였고 다시 배열로 변환 후 split로 신고한 유저와 신고당한 유저를 분리하였다. //[[ 'muzi', 'frodo' ]] 이런 형태로 신고 내용이 저장된다. let reports = [...new Set(report)].map((a) =&gt; { return a.split(\" \"); }); let counts = new Map(); //신고당한 횟수를 저장하는데 Map을 초기화하지 않고 || 연산자로 초기값을 설정한다. for (const bad of reports) { counts.set(bad[1], counts.get(bad[1]) + 1 || 1); } let good = new Map(); //메일 전송 횟수를 저장하는데 신고당한 사람의 횟수가 k와 같거나 크면 신고한 사람의 메일 전송 횟수를 1 증가시킨다. for (const report of reports) { if (counts.get(report[1]) &gt;= k) { good.set(report[0], good.get(report[0]) + 1 || 1); } } let answer = id_list.map((a) =&gt; good.get(a) || 0); return answer;}👩‍🌾 새로 알게 되었거나 중요한 포인트배열의 중복을 제거하기 위한 방법 ⭐️ Set ⇒ 중복 제거만을 위해선 제일 간단하게 처리할 수 있다. const report = [\"ryan con\", \"ryan con\", \"ryan con\", \"ryan con\"];const reports = [...new Set(report)]; // [\"ryan con\"] filter const report = [\"ryan con\", \"ryan con\", \"ryan con\", \"ryan con\"];const reports = report.filter((item, index) =&gt; { return report.indexOf(item) === index;}); //[\"ryan con\"] Map const report = [\"ryan con\", \"ryan con\", \"ryan con\", \"ryan con\"];const objUnique = {};report.forEach((el) =&gt; { objUnique[el] = true;});const arrUnique = Object.keys(objUnique); // [\"ryan con\"] " }, { "title": "참조 타입의 불변성 알아보기", "url": "/posts/immutable-in-javascript/", "categories": "study", "tags": "REACT, JAVASCRIPT, 불변성, 상태관리", "date": "2022-08-01 18:50:00 +0900", "snippet": "불변성(Immutable)🔖 불변성이란 상태를 변경하지 않는 것을 의미한다.🔖 불변성을 지키면 1. 무분별한 상태의 변경을 막을 수 있고 2.상태의 변경을 추적하기가 쉽다.🔖 자바스크립트에서 원시 타입은 불변성을 가지지만 참조 타입은 그렇지 않다. 참조 타입의 객체의 경우 메모리 힙 영역에 저장이 되어 내부 프로퍼티를 변경해도 같은 참조를 갖고 있다. 따라서 객체의 특정 프로퍼티만 변경하는 작업을 수행 후 다른 객체로 인식되지 않는다.🔖 Object.assign() 메서드를 이용하거나 ES6의 스프레드 연산자를 이용하여 이전 참조와 다른 참조로 변경할 수 있다. 각각의 메모리 공간에 할당되어 다른 객체로 인식된다. 하지만 두 가지 방법 모두 얕은 복사를 수행하기 때문에 내부의 프로퍼티가 참조인 경우 참조를 그대로 복사하여 완전히 다른 참조가 되지는 못한다.리액트에서의 불변성과 렌더링🔖 리액트는 props나 state가 변경되었을 때 컴포넌트를 리렌더링하는데 변경된 사실은 불변성을 이용해서 감지한다. 객체의 참조를 복사한다는 점을 이용해 단순히 참조만 비교하는 얕은 비교를 이용해서 변경이 일어났는지 확인한다. 그렇기 때문에 직접 state를 수정해서는 안된다.불변성 유지를 도와주는 라이브러리 (immer)자바스크립트에서 불변성을 유지하려면 Object.assign() 메서드 또는 ES6의 스프레드 연산자를 이용해야 하는데 이마저도 얕은 복사를 수행하므로 객체의 프로퍼티가 참조 타입이면 재귀를 통해 복사를 해야하는 번거로움이 생긴다.immer는 이를 대신하여 불변 객체를 관리해주는 자바스크립트 라이브러리다.React + Immer리액트의 useState와 useReducer 내부에 저장된 상태 값들은 불변성을 지닌다. 따라서 직접적으로 상태 값을 변경하지 않고 setState를 이용하며 변경하고자 하는 상태 값은 새로운 객체를 생성한 뒤 업데이트를 요청한다.const changeState = (newItem) =&gt; { //1️⃣ 새로운 객체로 갱신한다. setState(newItem); //2️⃣ updateState라는 프로퍼티만 갱신한다. setState((prevState) =&gt; { ...prevState, updateState : updatedValue});}immer의 produce 함수를 useState와 useReducer에서 사용할 수 있으며 새로운 객체를 생성하여 전달하지 않고 파라미터로 받은 원래의 상태 값을 변경하기만 하면 된다.useReducer + Immer어제 리액트 강의에서 만들었던 Practice Project에서 장바구니 컴포넌트에서 useReducer로 상태 값을 관리하고 있다. 이 부분을 immer를 사용한 코드로 변경해보기로 했다.기존 장바구니 컴포넌트의 상태 관리장바구니의 아이템 목록은 위와 같은 상태 값으로 구성되어 있다. 목록은 배열로 관리하고 각 요소들은 객체로 구성되어 있다.장바구니에 새 아이템이 추가하면 기존 아이템 목록(items)에 동일한 아이템이 추가되어 있는지 확인하고 이미 추가되어 있다면 그 객체의 수량(amount) 프로퍼티 값만 증가시켜 업데이트한다. 기존 코드에서 amount 상태 값 갱신과 관련이 없는 구문들은 생략하였다.//⚠️ 리듀서 함수는 호출되는 컴포넌트 외부에서 선언해도 되므로 CartProvider 외부에서 선언하였음const reducerFn = (state, action) =&gt; { if (action.type === \"ADD\") { const existedItem = state.items[existedItemIndex]; const updateItem = { ...existedItem, amount: existedItem.amount + action.payload.amount, }; const updateItems = [...state.items]; updateItems[existedItemIndex] = updateItem; return { items: updateItems, totalAmount: updatedTotalAmount }; }};const CartProvider = (props) =&gt; { const [cartState, dispatchAction] = useReducer(reducerFn, defaultState); const addItemCartToHandler = (newItem) =&gt; { dispatchAction({ type: \"ADD\", payload: newItem }); };};장바구니에 물품이 추가해서 이벤트가 발생하면 addItemCartToHandler이 호출되면서 리듀서 함수(reducerFn)가 실행된다.items라는 상태는 참조 타입 내에 참조 타입을 가지고 있는 구조다.(객체를 요소로 갖는 배열)그렇기 때문에 items 객체를 스프레드 연산자를 이용해 새 객체를 생성하더라도 내부 참조는 동일한 값을 가리킨다.const copyItems = [...state.items];console.log(state.items[0] === copyItems[0]); // true여기서 새 객체를 반환하기 위해서는 아래의 순서대로 작업이 필요하다. 업데이트 할 요소를 찾아 amount값을 변경한 객체를 생성한다. (Line 4 ~ 8) 배열의 인덱스로 업데이트할 배열의 요소를 찾은 후 스프레드 연산자로 새 객체를 생성하여 updateItem에 할당한다. 그 후에 items를 스프레드 연산자로 새 객체를 생성한다. (Line 10 ~ 11) 이전 상태 값과 다른 참조 값을 반환해야 하므로 스프레드 연산자를 이용하여 updateItems라는 변수에 새로운 객체를 할당한다. 그리고 1번에서 작업한 updateItem 요소를 업데이트해준다. 이처럼 새 객체를 반환하기 위해 스프레드 연산자를 사용한다. 이 부분을 immer로 대체해보자.immer의 produce 활용하기사용 방법은 Immer 공식 문서를 참고하였다.const reducerFn = produce((draft, action) =&gt; { if (action.type === \"ADD\") { const existedItem = draft.items[existedItemIndex]; existedItem.amount += action.payload.amount; }});const CartProvider = (props) =&gt; { const [cartState, dispatchAction] = useReducer(reducerFn, defaultState); /* ... */};immer의 produce 함수의 첫 번째 파라미터로 리듀서 함수를 전달한다.이 때 리듀서 함수는 원래 상태 값인 draft와 dispatch 함수가 보낸 action 값을 받을 수 있다. items에서 업데이트 할 항목을 찾은 후 재할당할 필요없이 바로 값을 갱신해주면 된다.useImmerReduceruseImmer 패키지의 useImmerReducer는 더 간단하게 immer를 사용할 수 있도록 해준다.useReducer 대신 useImmerReducer를 사용하면 produce 함수를 생략하고 기존 함수를 전달해줘도 동일하게 동작한다.const reducerFn = (draft, action) =&gt; { if (action.type === \"ADD\") { const existedItem = draft.items[existedItemIndex]; existedItem.amount += action.payload.amount; }};const CartProvider = (props) =&gt; { const [cartState, dispatchAction] = useImmerReducer(reducerFn, defaultState); /* ... */};마무리자바스크립트에서 불변성 유지를 쉽게 도와주는 라이브러리는 immer 이 외에도 lodash의 cloneDeep, immutable-js 등이 있다.매번 스프레드 연산자로 얕은 복사를 한 뒤 새 객체를 반환해주거나 깊은 복사 함수를 구글링해서 사용했는데 이런 라이브러리를 사용하면 수월하게 작업할 수 있을 거 같다.위에서 작업한 것처럼 코드도 굉장히 간단해져서 가독성도 훨씬 좋다. 🐝 참고 불변 객체와 immer 변하지 않는 상태를 유지하는 방법, 불변성(Immutable) immer 공식 문서 " }, { "title": "📸 2022-08-01", "url": "/posts/220801TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-08-01 15:56:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 참조 타입의 불변성 알아보기 리액트의 상태 값을 immer로 관리하기 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 프로그래머스에서 코딩 테스트하기" }, { "title": "📸 2022-07-31", "url": "/posts/220731TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-31 18:31:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 유데미 리액트 강의 섹션 11 : Practice Project : Building a Food Order App 구현 Ref, Portals, useState, useReducer 복습 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? useReducer의 리듀서 함수에서 새로운 상태 값을 반환할 때에는 기존 state값은 변경하지 않고 새로운 객체를 생성하여 반환하자! (useReducer뿐만 아니라 상태 값을 갱신할 때에는 기존 상태 값은 건드리지 말기)🌟 내일은 어떻게 해보고 싶으세요? 불편 객체와 immer 읽어보기 변하지 않는 상태를 유지하는 방법, 불변성(Immutable) 읽어보기" }, { "title": "📸 2022-07-29", "url": "/posts/220729TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-29 22:47:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 유데미 리액트 강의 122 ~ 128까지 수강하기 (context 심화) Hooks의 규칙 forwardRef와 useImperativeHandle 사용법 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? useImperativeHandle를 사용할 때 자식 컴포넌트의 React.forwardRef의 두 번째 파라미터로 ref를 전달 받는데 이 ref를 할당하지 않고 새로운 ref를 생성하여 할당하는 이유는??🌟 내일은 어떻게 해보고 싶으세요?리액트 훅을 사용할 때 지켜야 할 3가지 함수형 컴포넌트에서만 훅을 호출한다. 리액트 컴포넌트의 최상위 레벨에서만 호출해야 한다. 중첩 구문이나 if문 등의 블럭 구문 내에서 호출해서는 안 된다. useEffect 내부에서 참조하는 항목은 모두 의존성에 추가되어야 한다. useState나 useReducer로 인해 사용하는 함수들은 변경되지 않도록 리액트가 보장하므로 생략해도 된다." }, { "title": "React의 Ref", "url": "/posts/react-ref/", "categories": "study", "tags": "React", "date": "2022-07-29 19:56:00 +0900", "snippet": "Ref는 DOM 노드나 리액트 엘리먼트에 접근하는 방법을 제공한다. HTML 요소에 포커스를 주거나 애니메이션 수행을 위해 사용한다. Ref 전달하기는 컴포넌트가 자식 컴포넌트의 ref를 자신의 ref로서 외부에 노출시키게 합니다.useRef와 forwardRef//📄 Login.jsconst Login = () =&gt; { const emailRef = useRef(); const passwordRef = useRef(); return ( &lt;&gt; &lt;Input type=\"email\" ref={emailRef} /&gt; &lt;Input type=\"password\" ref={passwordRef} /&gt; &lt;/&gt; ); //📄 Input.js const Input = React.forwardRef((props, ref) =&gt; { return &lt;input type={props.type} ref={ref}&gt; });};부모 컴포넌트인 Login 컴포넌트에서 선언한 ref를 자식 컴포넌트인 Input 컴포넌트로 각각 전달한다. Input 컴포넌트에서 React.forwardRef로 컴포넌트를 생성하였고 React.forwardRef는 props와 ref 파라미터를 받아 React 노드를 반환하는 렌더링 함수를 받는다. 이런 방법으로 Input을 사용하는 컴포넌트들은 input DOM 노드에 대한 참조를 가져올 수 있고, 필요한 경우 DOM input을 직접 사용하는 것처럼 접근할 수 있다. ⚠️ 두 번째 ref 인자는 React.forwardRef와 같이 호출된 컴포넌트를 정의했을 때에만 생성됩니다. 일반 함수나 클래스 컴포넌트는 ref 인자를 받지도 않고 props에서 사용할 수도 없습니다.useImperativeHandleLogin에서 Input의 ref에 접근하기 위해서는 useImperativeHandle을 사용한다.위 Login 컴포넌트에 버튼 2개(focusEmail, focusPassword)와 각 버튼을 클릭하면 이메일 또는 비밀번호 Input에 focus를 주는 함수(loginInputFocusHandler, passwordInputFocusHandler)를 추가하였다.//📄 Login.jsconst Login = () =&gt; { const emailRef = useRef(); const passwordRef = useRef(); const loginInputFocusHandler = () =&gt; { emailRef.current.focus(); } const passwordInputFocusHandler = () =&gt; { passwordRef.current.focus(); } return ( &lt;&gt; &lt;Input type=\"email\" ref={emailRef} /&gt; &lt;Input type=\"password\" ref={passwordRef} /&gt; &lt;button id=\"focusEmail\" onClick={loginInputFocusHandler}&gt;Email Focus&lt;/button&gt; &lt;button id=\"focusPassword\" onClick={passwordInputFocusHandler}&gt;Password Focus&lt;/button&gt; &lt;/&gt; ); //📄 Input.js const Input = React.forwardRef((props, ref) =&gt; { const inputRef = useRef(); const activate = () =&gt; { inputRef.current.focus(); }; useImperativeHandle(ref, () =&gt; { return { focus: activate }; }); return &lt;input type={props.type} ref={inputRef}&gt; });};이메일 Input의 포커스를 위한 버튼을 클릭하면 emailRef.current.focus();가 실행되고 이 때 focus()는 Input에서 useImperativeHandle 내에서 반환된 객체의 focus라는 요소의 함수이다. focus는 activate라는 함수를 담고 있기 때문에 최종적으로 activate()가 실행된다.즉, focusEmail 버튼을 클릭하면 Input의 activate가 실행되며 input DOM 요소에 포커스가 잡힌다.다른 프로젝트에서 실제 사용한 forwardRef와 useImperativeHandle 알아보기Tockler는 애플리케이션의 이용 시간을 추적하는 서비스로 일렉트론과 리액트, 타입스크립트로 개발되었다.메인 화면 상단에는 기간을 선택하고 그 기간만큼의 이용 시간을 차트로 보여주는 기능이 있다. DataRangeInput에서 기간을 선택하는 input 요소의 값이 변경되면 datepicker의 선택된 날짜 값도 변경하는 내용이다.여기서 사용하는 datePicker 컴포넌트의 소스를 살펴보면 ref를 어떻게 사용하는지 알 수 있다.(실제 프로그램에서는 input 요소의 값을 임의로 변경할 수 없다. 나중에 소스 분석을 하게 되면 자세히 알아봐야겠다.) 아래 코드는 타입스크립트 문법은 생략하고 해당 내용을 설명하기 위한 코드만을 가져온 것이다. 실제 코드는 아래 깃헙 링크를 참고하면 된다. 📄 DatePicker.tsx 📄 DateRangeInput.tsx // 📄 DatePicker.tsxexport const DatePicker = React.forwardRef((props, ref) =&gt; { /* ... */ // 👇 DatePicker를 호출한 부모 컴포넌트에서 ref로 접근할 수 있도록 onDateSelect라는 함수를 반환한다. useImperativeHandler(ref, () =&gt; ({ onDateSelect: (date) =&gt; { dp.onDateSelect(date); }, })); /* ... */});// 📄 DateRangeInput.tsxexport const DateRangeInput = (props) =&gt; { const datePickerRef = useRef(); function handleInputChange(date) { if ( datePickerRef &amp;&amp; datePickerRef.current &amp;&amp; datePickerRef.current.onDataSelect ) { // 👇 onDateSelect는 DatePicker의 useImperativeHandler에서 노출시킨 함수이다. datepickerRef.current.onDateSelect(date); } } return ( /* ... */ &lt;Input onChange={handleInputChange} /* ... */ /&gt; &lt;DatePicker ref={datePickerRef} /* ... */ /&gt; /* ... */ )};DatePicker는 외부에서 ref를 전달받고 useImperativeHandler에서 외부에서 ref에 접근할 수 있는 onDateSelect라는 함수를 반환한다.그리고 DateRangeInput는 DatePicker에 datePickerRef라는 ref를 전달하고 Input의 이벤트 핸들러(handleInputChange)에서 이 ref를 통해서 DatePicker의 dp라는 리액트 컴포넌트의 요소를 호출한다." }, { "title": "📸 2022-07-28", "url": "/posts/220728TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-28 18:23:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React의 useContext 사용법 (참고)🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 주의사항에 Provider의 value prop이 바뀌면 매번 새로운 객체가 생성되므로 Provider가 렌더링 될 때마다 하위의 컴포넌트가 모두 리렌더링된다. 이를 방지하기 위해서는 state로 끌어올리고 그 state 값을 value prop으로 전달한다. Object.is({ a: \"1\" }, { a: \"1\" }); //falseconst obj = { a: \"1\" };Object.is(obj, obj); // true 객체 내부 데이터는 동일하더라도 각각 새로운 객체가 생성되어 다른 객체로 인식한다. Provider의 value prop에도 객체를 전달하면 렌더링 될 때마다 다른 객체로 인식되기 때문에 객체를 따로 저장한 후에 그 값을 value prop으로 사용해야 한다. 🌟 내일은 어떻게 해보고 싶으세요? 유데미 리액트 강의 122 ~ 128까지 수강하기 (context 심화)React의 Context context는 리액트 내부에서 전역적으로 state를 관리하는 저장소 개념이다. context를 이용하면 단계마다 일일이 props를 넘겨주지 않고(=prop chain을 구축하지 않고도) 컴포넌트 트리 전체에 데이터를 제공할 수 있다. React.createContext로 Context 객체를 만들고, Context.Provider로 context를 사용할 컴포넌트의 범위를 정하여 리액트에게 알려주고 내부 컴포넌트들에게는 context의 변화를 알린다. Context.Provider 내부에 있는 컴포넌트가 해당 context의 데이터에 접근하기 위해서는 Context.Consumer 또는 useContext를 사용한다. React.createContext const MyContext = React.createContext(defaultValue); 전역으로 관리하고 싶은 데이터를 defaultValue 매개변수로 전달한다. Context.Provider const App = () =&gt; { return ( &lt;MyContext.Provider value={providedValue}&gt; &lt;Toolbar /&gt; &lt;/MyContext.Provider&gt; );}; Provider 컴포넌트에는 value라는 prop을 전달해주는데 이 값이 하위 컴포넌트들에게 전달되고 이 value prop이 변할 때마다 리렌더링된다. 위 코드에서 Toolbar 컴포넌트는 MyContext.Provider 컴포넌트 내부에 위치하므로 MyContext.Provider에 전달되는 value prop이 변할 때마다 리렌더링된다. ⚠️ React.createContext의 파라미터로 전달한 defaultValue는 Provider를 찾지 못했을 때만 쓰이는 값이다. Context.Consumer const Toolbar = () =&gt; { return &lt;MyContext.Consumer&gt; {(ctx) =&gt; { return (&lt;ul&gt;{...}&lt;/ul&gt;) }} &lt;/MyContext.Consumer&gt;} Consumer 컴포넌트의 자식은 함수여야 한다. 이 함수의 파라미터는 context의 현재 값을 가져온다. 여기서 ctx는 providedValue를 가져온다. useContext const Toolbar = () =&gt; { const ctx = useContext(MyContext); return &lt;ul&gt;{...}&lt;/ul&gt;} MyContext.Consumer와 마찬가지로 MyContext.Provider 내부에서 useContext 훅으로 context에 접근할 수 있다. " }, { "title": "📸 2022-07-26", "url": "/posts/220726TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-26 23:26:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React의 useReducer와 useState React의 useContext 사용법 (진행중) 📖 도파민네이션 완독🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? [이번주 내로 하기] React - 이번주에 배운 Ref, Portals, useState, useReducer, useContext 복습하기 useState와 useReducer에 대한 글 읽어보기" }, { "title": "📸 2022-07-22", "url": "/posts/220722TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-22 23:26:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React의 useReducer 사용법🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 이제까지 useState를 사용할 때 다른 상태 값을 setState에서 사용해도 문제가 없었는데 언제 useState를 사용하고 언제 useReducer를 사용해야 하는가?🌟 내일은 어떻게 해보고 싶으세요? React - 이번주에 배운 Ref, Portals, useState, useReducer 복습하기 React - useContext 알아보기" }, { "title": "📸 2022-07-21", "url": "/posts/220721TIL/", "categories": "TIL", "tags": "클린코드, 좋은코드나쁜코드", "date": "2022-07-21 23:32:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 좋은 코드, 나쁜 코드 3장 읽기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? React - useReducer 알아보기" }, { "title": "📸 2022-07-19", "url": "/posts/220719TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-19 23:32:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React에서 JSX 요소 반환하기 React useEffect 사용법 useEffect의 clean-up으로 디바운싱 구현해보기 Portals &amp; Ref Portals 사용법과 이벤트 버블링 Ref 사용법 실용주의 프로그래머 1장 읽기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? React.createElement으로 하나의 태그만 반환해야 한다고 하는데 이유가 궁금 예전부터 듣기는 많이 들었던 디바운싱(Debouncing)과 쓰로틀링(Throttling) 더 자세히 알아보기🌟 내일은 어떻게 해보고 싶으세요? React - useReducer 알아보기React에서 JSX 요소 반환하기하나의 컴포넌트는 햔 개의 요소만을 반환해야 한다. 따라서 JSX 문법을 사용할 때에는 아래와 같이 하나의 태그만 반환해야 한다.const Content = () =&gt; { return ( &lt;h2&gt;title&lt;/h2&gt; &lt;p&gt;description&lt;/p&gt; );};Content 컴포넌트는 title과 description을 보여주는 태그로 구성되어있다.하지만 반환 시에는 하나의 태그만 반환해야 하므로 위와 같이 컴파일을 하게 되면 오류가 난다.JSX 문법을 사용하여 컴포넌트 내용을 반환하기 위해서는 다음과 같은 방법이 있다. 최상위에 div태그로 감싸기 const content = () =&gt; { return ( &lt;div&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;p&gt;description&lt;/p&gt; &lt;/div&gt; );}; 가장 간단하고 많이 사용하는 방법이지만 이와 같이 감싸는 용도의 div를 사용한 여러 컴포넌트가 겹쳐지면 &lt;div&gt; soup(div 중첩)가 발생한다. div가 많이 중첩될수록 속도가 느려지고 스타일을 적용할 때에도 번거로움이 있을 수 있다. JSX 요소들을 배열에 담아 반환 const content = () =&gt; {return ( [ &lt;h2&gt;title&lt;/h2&gt; , &lt;p&gt;description&lt;/p&gt; ] &lt;/div&gt;);}; 배열로 반환하게 되면 목록 유형의 컴포넌트와 같이 각 요소마다 key 값을 부여해야 한다. UI 요소 없는 눈속임 컴포넌트로 감싸기 const Wrapper = (props) =&gt; { return props.children;};const content = () =&gt; { return ( &lt;Wrapper&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;p&gt;description&lt;/p&gt; &lt;/Wrapper&gt; );}; 여기서 Wrapper 컴포넌트는 JSX 문법으로 UI 요소를 사용하지 않고 그저 파라미터로 전달받은 props의 하위 내용만 반환한다. content 컴포넌트의 내용을 Wrapper 컴포넌트로 감싸주면 불필요한 div 태그를 사용하지 않아도 되어 코드를 관리하고 스타일을 적용하기에 훨씬 수월하다. &lt;React.fragment&gt;(또는 &lt;&gt;&lt;/&gt;) 사용하기3번의 눈속임 컴포넌트의 기능을 리액트에서 제공해주는데 이것이 바로 &lt;React.fragment&gt;이다. " }, { "title": "📖 실용주의 프로그래머", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8/", "categories": "book", "tags": "클린코드", "date": "2022-07-19 15:15:00 +0900", "snippet": "1. 실용주의 철학🔖 Tip 1 자신의 기예에 관심을 가져라.🔖 Tip 2 자기 일에 대해 생각하라.Topic 1 당신의 인생이다🔖 Tip3 당신에게는 에이전시가 있다. 당신에게는 스스로의 행동을 직접 결정할 수 있는 힘이 있다.Topic 2 고양이가 내 소스 코드를 삼켰어요 실용주의 철학의 초석 중 하나는 자신과 자신의 행동에 대해 책임을 지는 것이다. 실용주의 프로그래머는 자신의 경력에 대해 책임을 지고, 자신의 무지나 실수를 주저 없이 인정한다.🔖 Tip 4 어설픈 변명 말고 대안을 제시하라. 안된다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라. 여러분이 “잘 모르겠어요.”라고 말했다면, 꼭 바로 이어서 “하지만 알아볼게요.”라고 말하라. 모른다는 것은 인정하더라도 전문가답게 책임을 지는 좋은 방법이다.Topic 3 소프트웨어 엔트로피🔖 Tip 5 깨진 창문을 내버려 두지 말라. 발견하자마자 바로 고쳐라. 적절히 고칠 시간이 없다면 일단 판자로 덮는 것만이라도 하라. 소프트웨어의 부패(=기술부채)에 영향을 주는 다른 요인들도 더 알아보겠지만, 방치는 다른 어떤 요인보다도 부패를 더 가속시킨다.Topic 4 돌멩이 수프와 삶은 개구리🔖 Tip 6 변화의 촉매라 되라. 큰 무리 없이 요구할 수 있을 만한 것을 찾아라. 그리고 그걸 잘 개발하라. 일단 무언가 생기면 사람들에게 보여 주고 그들이 경탄하게 하라. 물러나 앉아 여러분이 애초에 원했던 그 기능을 추가해 달라고 사람들이 부탁하기 시작할 때까지 기다려라. 계속되는 성공에 합류하기란 쉽다. 미래를 살짝이라도 보여 주면 사람들은 도와주기 위해 모여들 것이다. “허락을 얻는 것보다 용서를 구하는 것이 더 쉽다.” : 무엇이 가능한지 물어보고 판단하느니 차라리 일단 저지르고 예외가 발생하면 해당 예외를 처리하게 하는 방식이다. 🔖 Tip 7 큰 그림을 기억하라. 큰 그림에 늘 주의를 기울여라. 당장 하고 있는 일에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는지 늘 살펴보라. 변화를 촉진하려고 할 때 여러분이 돌멩이 수프를 만드는지 아니면 개구리 수프를 만드는지 어떻게 판단할 수 있을까? 그 판단은 주관적인가, 객관적인가?Topic 5 적당히 괜찮은 소프트웨어 적당히 괜찮은이라는 표현은 너절하거나 형편없는 코드를 의미하지 않는다. 시스템이 성공하려면 사용자의 요구 사항을 충족해야 한다. 기본적인 성능이나 개인 정보 보호, 보안 기준도 맞추어야 한다. 우리가 여기서 하고 싶은 말은 여러분이 생산해 낸 것이 적당히 괜찮게 사용자의 요구를 충족하는지 결정하는 과정에서 사용자가 참여할 기회를 가져야 한다는 것이다.🔖 Tip 8 품질을 요구 사항으로 만들어라. 오늘의 훌륭한 소프트웨어는 많은 경우 환상에 불과한 내일의 완벽한 소프트웨어보다 낫다. 사용자에게 뭔가 직접 만져볼 수 있는 것을 일찍 준다면, 피드백을 통해 종국에는 더 나은 해결책에 도달할 수 있을 것이다. 완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라. 그냥 넘어가고 코드를 현재 상태로 한동안 그대로 놓아두라. 완벽하지 않을 수도 있다. 그래도 괜찮다. 완벽해지기란 불가능하다.Topic 6 지식 포트폴리오 지식의 대한 투자가 언제나 최고의 이윤을 낸다. - 벤저민 프랭클린 여러분의 지식과 경험이야말로 가장 중요하고 날마다 쓰이는 전문가 자산이다. 하지만 불행히도 이 자산은 기한이 있는 자산이다. 새로운 언어, 기술, 환경이 개발됨에 따라 지식은 옛것이 된다.🔖 Tip 9 지식 포트폴리오에 주기적으로 투자하라. 매년 새로운 언어를 최소 하나는 배워라 기술 서적을 한 달에 한 권씩 읽어라 기술 서적이 아닌 책도 읽어라 수업을 들어라 지역 사용자 단체나 모임에 참여하라 다른 환경에서 실험해 보라 요즘 흐름을 놓치지 말라 투자를 지속하는 것이 중요하다. 한 기술의 새로운 용어나 기능에 익숙해지면 다음으로 나아가라. 또 다른 것을 배워라.🔖 Tip 10 읽고 듣는 것을 비판적으로 분석하라. “왜냐고 다섯 번 묻기” 누구에게 이익이 되나? 어떤 맥락인가? 언제 혹은 어디서 효과가 있을까? 왜 이것이 문제인가?Topic 7 소통하라!🔖 Tip 11 한국어든 영어든 하나의 프로그래밍 언어일 뿐이다.사람을 위한 글을 쓰는 것도 코드를 쓰는 것과 똑같다. 하루 중 많은 시간을 소통하며 보내기 때문에 이를 잘할 필요가 있다.🔖 Tip 12 무엇을 말하는가와 어떻게 말하는가 모두 중요하다. 말하고 싶은게 무언지 알라 무엇을 말할지 미리 계획하라. 개요를 작성하라. 그리고 자문하라. 이렇게 하면 내가 표현하고 싶은 것을 듣는 사람에게 통하는 방법으로 잘 전달할 수 있나? 그렇게 될 때까지 다듬어라 스타일을 고르고 멋져 보이게 하라 전달하는 스타일을 청중에 어울리도록 조정하라. 🔖 Tip 13 문서를 애초부터 포함하고, 나중에 집어넣으려고 하지 말라. 소스 코드의 주석으로 보기 좋은 문서를 쉽게 생성할 수 있다. 모듈과 외부로 노출하는 함수에는 주석을 다는 것을 추천한다. API가 아닌 코드에 주석을 쓸 때는 왜 이렇게 되어 있는지, 즉 코드의 용도와 목적을 논해야 한다. 어떻게 동작하는지는 코드가 이미 보여 주기 때문에 이에 대해 주석을 다는 것은 사족이다." }, { "title": "📸 2022-07-18", "url": "/posts/220218TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-18 23:32:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React의 연습 문제 해설보면서 코드 다시 확인하기 React의 Key 🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?🌟 내일은 어떻게 해보고 싶으세요? 좋은 코드, 나쁜 코드 계속 읽기 코딩 테스트 문제 풀기" }, { "title": "React의 Key", "url": "/posts/react-key/", "categories": "study", "tags": "React", "date": "2022-07-18 17:26:00 +0900", "snippet": "리액트에서 목록 컴포넌트(ul)에는 각 요소(li)마다 고유 키를 부여해줘야 한다. 이 때, 키 값으로 반복문의 index를 사용하면 콘솔에 오류는 뜨지 않지만 좋은 방법은 아니다.Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별한다. index를 key 값으로 사용한다면 렌더링 할 때마다 목록에 항목이 추가/삭제 또는 필터링되는 경우 index는 달라지므로 고유하다고 할 수 없다.const App = () =&gt; { const [userList, setUserList] = useState([]); const addUser = (newUser) =&gt; { setUserList((prevUserList) =&gt; [newUser, ...prevUserList]); }; return ( &lt;div&gt; &lt;ul&gt; {userList.map((item, index) =&gt; ( &lt;li key={index}&gt; {item.username}({item.userage} years old) &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );}; 🐝 참고 [React] 배열의 index를 key로 쓰면 안되는 이유 Index as a key is an anti-pattern" }, { "title": "📸 2022-07-17", "url": "/posts/220717TIL/", "categories": "TIL", "tags": "HTML", "date": "2022-07-17 22:45:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? WebDevCurriculum - Quest 01. HTML과 웹의 기초 내용 정리🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 시멘틱 태그를 써오면서도 왜 사용하는지, 각자 의미가 무엇인지 모르고 퍼블리싱이 그렇게 왔으니 온대로 적용했었다. 생각보다 시멘틱 태그의 역할은 중요하고 바닐라 자바스크립트뿐만 아니라 리액트로 UI 컴포넌트를 만들 때에도 div만 사용하지 말고 시멘틱 태그를 적용해봐야겠다." }, { "title": "📸 2022-07-16", "url": "/posts/220716TIL/", "categories": "TIL", "tags": "클린코드, 좋은코드나쁜코드", "date": "2022-07-16 23:12:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 좋은 코드, 나쁜 코드 2장 읽기 Obsidian 설치🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? Obsidian을 처음 설치했다. 책이나 공부한 내용들을 두서없이 정리하고 싶을 때 사용할 용도. 그리고 연정이 블로그에서 그래프 뷰를 봤는데 예뻐보여서 써보려고 한다ㅎ… 근데 한글 씹힘?이 너무 심해서 계속 이러면 불편할 거 같다. 관련 카페에 검색해보니 언어 설정을 한국어로 변경하라고 해서 해보니까 일단 괜찮아진거 같다.🌟 내일은 어떻게 해보고 싶으세요? 좋은 코드, 나쁜 코드 계속 읽기 WebDevCurriculum - Quest01 내용 정리" }, { "title": "📸 2022-07-15", "url": "/posts/220715TIL/", "categories": "TIL", "tags": "블로그, CSS", "date": "2022-07-15 23:48:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 블로그에 강의 정보 확인할 수 있는 페이지 추가🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?프로그레스바가 여러 개라서 그런지 페이지를 켜두면 노트북 발열도 심하다.. 아직 발열의 원인이 이 페이지인지 확실하지 않아서 지켜보다가 계속 이러면 빼야겠다ㅠㅠ블로그 페이지 추가올해 상반기에 궁금했던 기술 또는 기법에 대한 강의를 많이 구입했다.유데미, 인프런, 드림코딩, 노마드코더 등 여기 저기서 강의를 사둔 후에 미루고 있는게 대다수다.그래서 하나의 페이지에서 여러 사이트의 강의로 이동하고 내 학습 진도를 간략하게나마 확인하고 관리하기 위해 새로운 페이지를 만들었다.nav에 메뉴 추가 좌측 nav에 메뉴를 등록하기 위해서 /_tabs 내부에 원하는 메뉴명의 md 파일을 추가한다.난 study라는 메뉴명을 추가하기 위해서 study.md를 추가하고 다른 파일을 참고해서 내용을 수정했다. /_layouts/study.html를 추가한다. 그리고 페이지에서 보여줄 내용으록 구성한다. 그러고 빌드하면 sidebar.html에서 동적으로 메뉴를 추가해준다. 동시에 새 페이지로 이동할 route 작업되어 /study로 이동하고 2번의 html파일의 내용을 불러온다.프로그레스바 추가진도율을 표시하기 위해 차트를 찾다가 가독성은 별로지만 귀여운 프로그레스 바를 찾았다.강의마다 진도율을 표시하고 싶은데 CSS에서 percentage를 계산할 때 사용하는 변수가 정해져있어 진도율마다 class를 추가했다..tube .liquid .percentage { position: absolute; height: var(--tube-percentage); width: 100%; bottom: 0; left: 0; z-index: 80; transition: 1s;}.tube .liquid .percentage-50 { position: absolute; height: 4%; width: 50%; bottom: 0; left: 0; z-index: 80; transition: 1s;}그러다보니 중복이 너무 많아졌는데 이걸 어떻게 줄여야할지 CSS를 잘 몰라서 더 찾아봐야할거 같다…학습 상태 표시학습하기 전, 학습 중, 학습 완료로 상태를 나누어 강의마다 표시해두었다. 참고 상태별 뱃지강의별 기술 태그 추가이건 아직 구상하지 못했지만 각 강의마다 무엇을 배울 수 있는지 태그 형식으로 추가하려고 한다.이 블로그의 기본 구성에 태그가 있어서 그걸 참고하려고 한다." }, { "title": "📖 좋은 코드, 나쁜 코드", "url": "/posts/%EC%A2%8B%EC%9D%80%EC%BD%94%EB%93%9C%EB%82%98%EC%81%9C%EC%BD%94%EB%93%9C/", "categories": "book", "tags": "클린코드, 좋은코드나쁜코드", "date": "2022-07-14 23:48:00 +0900", "snippet": "1. 코드 품질코드 품질이 소프트웨어의 품질에 미치는 영향 최초 요구 사항을 완전하게 충족 요구 사항의 변화가 있을 때 사소한 추가 작업만이 필요 오류 발생 시 시스템이 복구되거나 부분적으로 작동🔖 고품질 코드는 신뢰할 수 있고, 유지보수가 쉬우며, 버그가 적은 소프트웨어를 생산할 수 있다.코드 품질의 목표 코드는 작동해야 한다. 코드의 첫 번째 목표는 그것이 애초 작성된 목적대로 동작해야 한다는 것이다. 코드는 작동이 멈추면 안 된다. 코드가 작동하지 않을 수도 있는 상황 코드는 다른 코드에 의존할 수 있는데, 그 코드가 수정되고 변경될 수 있다. 새로운 기능이 필요할 때 코드를 수정해야 할 수도 있다. 우리가 해결하려고 하는 문제는 시간이 지남에 따라 변경된다. 소비자 선호, 비즈니스 요구, 고려해야 할 기술 등이 바뀔 수 있다. 현재는 잘 돌아가지만 미래에 제대로 동작하지 않는다면 그 코드는 별로 유용한 코드가 아니다. 당장 돌아가는 코드를 만들기는 쉽지만, 변화하는 환경과 요구 사항에도 불구하고 계속 작동하는 코드를 만드는 것은 훨씬 더 어렵다. 코드가 계속 작동하도록 보장하는 것은 소프트웨어 엔지니어가 직면하는 큰 과제 중 하나이며, 코딩의 모든 단계에서 고려해야 할 사항이다. 코드는 변경된 요구 사항에 적응할 수 있어야 한다. 코드나 소프트웨어가 시간이 지남에 따라 어떻게 변할지 완벽하고 정확하게 예측하는 것은 불가능하다. 하지만 변한다는 사실 자체를 완전히 무시해야 하는 것은 아니다. 코드는 이미 존재하는 기능을 중복 구현해서는 안 된다. 이미 있는 코드는 다시 작성하지 않는다는 개념은 양방향으로 적용된다. 어떤 하위 수준의 문제를 해결하기 위해 다른 개발자가 이미 코드를 작성했다면, 그것을 해결하기 위해 자신의 코드를 작성하기보다는 그들의 코드를 사용해야 한다. 마찬가지로 자신이 이미 코드를 작성했다면, 다른 개발자들이 동일한 문제를 해결하기 위해 자신만의 코드를 다시 작성하지 않도록 쉽게 재사용할 수 있는 방식으로 코드를 구성해야 한다. 코드 품질의 핵심 요소 코드는 읽기 쉬워야 한다. 코드의 가독성이 떨어진다면, 다른 개발자가 그 코드를 이해하는 데 많은 시간을 들여야 한다. 또한, 코드의 기능에 대해 잘못 이해하거나 몇 가지 중요한 세부 사항을 놓칠 가능성 역시 크다. 코드는 예측 가능해야 한다. 코드가 예상에서 벗어나는 일을 한다면, 그 코드를 사용하는 개발자는 그 상황을 알지 못하거나 그 상황에 대처할 생각을 하지 못할 것이다. 코드가 예상을 벗어나는 일을 수행하지 않는지 주의 깊게 살펴야 하고, 할 수 있다면 그런 코드를 작성하지 않도록 노력해야 한다. 코드를 오용하기 어렵게 만들라. 코드를 모듈화하라. 모듈화된 시스템은 일반적으로 이해하기 쉽고 추론하기 쉬운데, 그닝이 관리 가능한 단위로 나누어지고 기능 단위 간 상호작용이 잘 정의되고 문서화되기 때문이다. 코드가 모듈화되어 작성되면 처음에 작동이 시작되고 그 후에도 계속해서 잘 작동할 가능성이 커진다. 왜냐하면 코드가 하는 일을 개발자들이 오해할 소지가 적기 때문이다. 코드를 재사용 가능하고 일반화할 수 있게 작성하라. 재사용성 : 어떤 문제를 해결하기 위한 무언가가 여러 가지 다른 상황에서도 사용될 수 있음 일반화성 : 개념적으로는 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음 코드가 재사용할 수 있고 일반화되어 있으면 하나 이상의 상황에서 사용할 수 있고, 여러 가지 문제를 해결할 수 있다. 이런 코드는 시간과 노력을 절약해주고 더 신뢰할 수 있는데, 그 이유는 실제 서비스 환경에서 이미 시도되고 테스트된 논리를 재사용하기 때문이다. 테스트가 용이한 코드를 작성하고, 제대로 테스트하라. 코드의 테스트 용이성이 낮으면 제대로 테스트하는 것이 불가능할 수 있다. 현재 작성 중인 코드의 테스트 용이성을 확인하기 위해 코드를 작성하면서 어떻게 테스트할 것인가?를 계속 자문하는 것이 좋다. 즉, 코드를 다 작성하고 나서 테스트에 대해 생각해서는 안 된다. 테스트는 코드 작성의 모든 단계에서 필수적이고 기본적인 부분이다. 고품질 코드 작성은 일정을 지연시키는가? 단기적으로는 고품질 코드를 작성하는 데 시간이 더 걸릴 수 있다는 것이다. 하지만 중요한 소프트웨어를 개발하고 있다면, 일반적으로 고품질 코드를 작성하는 것이 중장기적으로는 개발 시간을 단축해준다. 코드 품질을 고려하지 않고 먼저 떠오르는 대로 코딩하면 처음에는 시간을 절약할 수 있다. 그러나 이런 코드는 머지않아 취약하고 복잡한 코드베이스로 귀결될 것이며, 점점 더 이해하기 어렵고 추론할 수 없는 코드가 된다.2. 추상화 계층왜 추상화 계층을 만드는가?어떤 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 몇 개의 개념만을 다루기 때문에 개별 코드는 특별히 복잡해 보이지 않을 것이다. 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다.추상화 계층 및 코드 품질의 핵심 요소 가독성 개발자들이 코드베이스에 있는 코드의 모든 세부 사항을 이해하는 것을 불가능하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 상당히 쉽다. 모듈화 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다. 재사용성 및 일반화성 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다. 그리고 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다. 테스트 용이성 코드가 추상화 계층으로 깨끗하게 분할되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다. 코드의 계층 API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 이외의 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다. 코드의 일부를 작성하거나 수정할 때, API에 이 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분되어 이루어진 것이 아니다.함수 관점에서의 추상화 단일 업무 수행 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성 일단 함수를 작성했으면 작성된 코드를 문장으로 만들어보면 좋다. 문장을 만들기 어렵거나 너무 어색하면 함수가 너무 길다는 것을 의미하고 더 작은 함수로 나누는 것이 유익할 것이다. 함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다.클래스 관점에서의 추상화 응집력 : 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로, 좋은 클래스는 매우 응집력이 강하다. 순차적 응집력 : 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다. 기능적 응집력 : 몇 가지 요소들이 모여서 하나의 일을 성취하는 데 기여할 때 발생한다. 관심사의 분리 : 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙 단일 클래스 내에 얼마나 다른 개념이 들어가 있는지, 그리고 어떤 로직이 재사용이나 재구성에 적합한지에 대해 개발자가 신중하게 생각하지 않으면 클래스는 종종 너무 커진다. 한 클래스는 오직 한 가지 일에만 관심을 가져야 한다 혹은 클래스는 응집력이 있어야 한다와 같은 경험칙은 개발자들이 더 높은 품질의 코드를 작성하기 위해 존재한다.인터페이스 관점에서의 추상화 추상화 계층을 깔끔하게 구현하는 코드를 만드는 데 있어 인터페이스는 매우 유용한 도구다. 주어진 하위 문제에 대해 둘 이상의 서로 다른 구체적인 구현이 가능하고 이들 구현 클래스 사이에 전환이 필요할 때는 추상화 계층을 나타내는 인터페이스를 정의하는 것이 가장 좋다. 주어진 추상화 계층에 대해 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없더라도 여전히 인터페이스를 사용할 것을 권고한다. 장점 퍼블릭 API를 매우 명확하게 보여준다. 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다. 테스트를 쉽게 할 수 있다. 같은 클래스로 두 가지 하위 문제를 해결할 수 있다. 단점 더 많은 작업이 필요하다. 코드가 복잡해질 수 있다. 층이 너무 얇아질 때 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드(보일러 플레이트)로 인해 코드의 양이 늘어난다. 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다. 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 많은 노력이 필요하다. 이로 인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다. 코드를 서로 다른 계층으로 분할해서 얻는 장점과 비교하면 이 비용이 상당히 낮은 것이지만, 분할을 위한 분할은 의미가 없다는 것을 명심해야 한다. 일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 더 문제가 될 수 있다. 따라서 어떤 것이 더 나을지 확실하지 않다면, 너무 많은 계층을 남용하는 결과를 가져오더라도 계층을 여러 개로 나누는 것이 한 계층 안에 모든 코드를 집어넣는 것보다 낫다. 최선의 조언은 자신이 만든 계층이 코드의 가독성을 높이고, 재사용할 수 있고, 일반화할 수 있으며, 모듈화되고, 테스트를 용이하게 하는지를 스스로 판단하고 신중하게 생각하는 것이다." }, { "title": "📸 2022-07-14", "url": "/posts/220714TIL/", "categories": "TIL", "tags": "REACT", "date": "2022-07-14 23:48:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? React - useState와 컴포넌트간의 데이터 전달 좋은 코드, 나쁜 코드 서론 읽기🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요?강의에서 form의 submit 시킬 때 event.preventDefault()로 submit 기본 동작은 막고 버튼 이벤트를 실행시킨다. form의 데이터를 어딘가로 전송하는게 아니니까 submit 기능말고 button에 바로 onClick 이벤트로 동작을 구현해도 동일하지 않을까?// 1️⃣ input과 button을 form 요소 안에 위치시키고 submit 시킨 후 이벤트 핸들러 동작const AddUserByForm = (props) =&gt; { const addUserHandler = (event) =&gt; { event.preventDefault(); // 👇 실질적으로 원하는 동작 console.log(\"addUserHandler\"); } return ( &lt;form onSubmit={AddUser}&gt; &lt;label htmlFor=\"name\"&gt; &lt;input type=\"text\" id=\"name\" /&gt; &lt;button type=\"submit\"&gt;Add&lt;/button&gt; &lt;/form&gt; );}// 2️⃣ button에 onClick 이벤트에 바로 함수 연결const AddUserByButton = (props) =&gt; { const addUserHandler = () =&gt; { // 👇 실질적으로 원하는 동작 console.log(\"addUserHandler\"); } return ( &lt;label htmlFor=\"name\"&gt; &lt;input type=\"text\" id=\"name\" /&gt; &lt;button onClick={addUserHandler}&gt;Add&lt;/button&gt; );}🌟 내일은 어떻게 해보고 싶으세요? 좋은 코드, 나쁜 코드 계속 읽기" }, { "title": "React의 컴포넌트간의 상태 관리", "url": "/posts/react-state/", "categories": "study", "tags": "React", "date": "2022-07-14 17:23:00 +0900", "snippet": "상태 관리하기 useState 사용하기const [userList, setUserList] = useState(\"\");const addUser = (newUser) =&gt; { setUserList([...userList, newUser]);}; 2개 이상의 컴포넌트간의 이벤트와 데이터 전달 하위 컴포넌트에서 상위 컴포넌트로 데이터 보내는 방법 여러 컴포넌트에서 동일한 데이터를 사용한다면 그 컴포넌트들의 부모 컴포넌트에서 데이터의 상태를 관리하고 자식에게 전달해주면 된다. 연습 프로젝트 https://codesandbox.io/s/zen-stallman-0vbzj0 🐝 참고 React 완벽 가이드 with Redux, Next.js, TypeScript" }, { "title": "📸 2022-07-13", "url": "/posts/220713TIL/", "categories": "TIL", "tags": "블로그", "date": "2022-07-13 23:48:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? 개발자 망하게 하는 사고방식 😱 (개발팁 5가지) 블로그 메인 수정🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 블로그를 커스텀할 수 있는 방법이 많은거 같아서 더 찾아봐야겠다. 세팅하는 것보다는 훨씬 쉬울 거 같다.새로운 메뉴랑 페이지도 새로 추가해서 포스트말고도 뭔가 더 작업을 해봐야겠다.🌟 내일은 어떻게 해보고 싶으세요? 리액트 강의 듣기💡 개발자로써 정체된다고 느껴지고 불안할 때 극복하는 팁1. 대부분의 사람들은 가면 증후군을 가지고 있다.부정적인 생각(ex. 내가 과연 좋은 개발자가 될 수 있을까, 내 진짜 실력이 들통나면 어떡하지)이 든다면 내가 지금 왜 이런 생각을 하고 있는지 고민해보고 상황을 객관적으로 바라보고 파악하기2. 나는 항상 다른 사람의 하이라이트 순간을 보고 있다.잘하는 사람들을 보고 저 사람은 타고 나서 잘하는게 아니라 많은 연습과 노력이 있었을 것이라고 생각하기타고 난 사람은 못이긴다는 생각말고 그 사람의 연습과 노력을 본받고 나도 따라하기 Fixed Mindset vs Growth Mindset Fixed Mindset : 실패를 싫어하고 성장해나가기가 어려움 Growth Mindset : 지속적으로 노력하면 뭐든 해낼 수 있다. 실패를 두려워하지않고 늘 배울 준비가 되어 있는 자세 3. 모든걸 다 아는 완벽한 전문가가 될 수 없다는 것을 인정한다.프런트엔드만 해도 정말 많은 기술과 프레임워크들이 있기 때문에 모든걸 알 수 없다.취업/이직 분야 선정 -&gt; 그에 맞는 기술을 활용한 프로젝트 고민해보기 -&gt; 중요도와 우선순위 정하기4. 내가 취약하다고 느끼는 부분을 분석해 본다. 약점에 대해 생각하기 이전에 강점에 대해서 생각해보기 내 강점을 어떻게 더 강하게 만들까/ 나만의 독보전인 무기는 무엇인가 나의 치명적인 약점이 뭘까? 업무를 수행하는 데 있어서 정말 개선이 필요한 약점을 한가지씩 공략하여 개선해나가기5. 성장의 길을 택하자(Growth Mindset)사진 출처 잘하는 것만 계속 하는 COMFORT ZONE에만 머문다면 성장할 수 없다. 우물 안 개구리가 된다. 새로운 것을 할 때 두려움을 느끼지만 점차 성장하게 된다. 내가 성장하고 있기 때문에 이런 생각을 하고 있는거구나 생각하기! like 성장통 어제보다 나은 오늘의 나를 생각하기 (어제보다 오늘의 내가 좀 더 똑똑한데..?ㅎ) 🐝 GROWTH ZONE과 관련된 좋은 글 How to Leave Your Comfort Zone and Enter Your ‘Growth Zone’📄 블로그 메인 수정포스트 목록에 글의 내용을 두 줄씩 보여주는데 조금 난잡하다는 생각이 들어서 velog처럼 서브타이틀을 넣기로 했다. _config.yml에 subtitle이라는 추가하고 jekyll-archives: enabled: [categories, tags, subtitle] 서브 타이틀을 추가하고 싶은 글에는 subtitle: [7월 13일 배우고 읽은 것] 형식으로 추가해줬다. home.html에 subtitle을 추가한 경우 subtitle을 보여주게 하고 없다면 글 내용을 200자까지 보여주도록 분기 처리했다. ⚠️ 포스트 작성 시 주의해야 할 점 파일명 yyyy-mm-dd-[제목].md형식인데 날짜가 달라도 같은 제목의 파일이 두 개 이상인 경우에 포스트의 경로를 못잡아준다. 예를 들어 2022-07-12-TIL.md과 2022-07-13-TIL.md는 /posts/TIL/라는 같은 링크가 걸리고 이 경로는 더 늦은 날짜의 포스트로 이동시킨다.그래서 TIL 파일의 타이틀에도 날짜를 붙이기로 했다." }, { "title": "Git의 restore, revert, reset의 차이점", "url": "/posts/git-restore-and-revert-and-reset/", "categories": "study", "tags": "Git", "date": "2022-07-12 23:48:00 +0900", "snippet": "restore, revert, reset의 차이점여러번 반복해도 이 3개가 너무 헷갈린다. restore : 수정사항을 되돌린다. //👇 HEAD가 참조하는 파일명에 해당하는 파일의 내용으로 되돌린다. 워킹트리에 존재하는 수정사항을 로컬 저장소의 내용으로 되돌린다.git checkout HEAD [파일명]git restore [파일명]//👇 HEAD의 특정 커밋 또는 1단계 전 커밋의 내용으로 HEAD가 이동한다.git checkout [커밋ID]git checkout HEAD~1//👇 해당 커밋의 파일 내용으로 복구한다. HEAD가 이동하는 것이 아니라 파일 내용만 복원한다.git restore --source [HEAD~1 또는 커밋ID] [파일명]//👇 스테이징된 파일을 되돌린다. (git add 취소)git restore --staged [파일명] reset : 커밋만 삭제한다. 현재 워킹트리에서 작업하는 내용은 그대로 유지된다. //👇 커밋ID 이후의 커밋 기록은 모두 삭제된다.git reset [커밋ID]//👇 커밋ID에 해당하는 내용으로 모두 되돌아간다. 커밋ID 이후의 커밋 기록은 물론 수정사항이 모두 삭제된다.git reset --hard [커밋ID] revert : 커밋을 엎어쓴다. 커밋 자체를 삭제하지 않고 새로운 커밋으로 이전 커밋을 복원시킨다. git revert [커밋ID] 🐝 참고 Git &amp; Github 실무 활용 완벽 가이드" }, { "title": "📸 2022-07-12", "url": "/posts/220712TIL/", "categories": "TIL", "tags": "GIT", "date": "2022-07-12 23:48:00 +0900", "snippet": "🔥 오늘 어디에 도전해보셨고, 무엇을 배우셨나요? git의 restore, revert, reset 사용법 WebDevCurriculum - Quest 00. 형상관리 시스템 내용 정리🌊 학습하시면서 궁금하신 부분이나, 어려웠던 점은 뭘까요? 실무에서 git을 사용했지만 restore, revert, reset은 이번에 강의 들으면서 처음 써봤다. 그래서 아직 이 3개가 헷갈린다.🌟 내일은 어떻게 해보고 싶으세요? WebDevCurriculum - Quest 00. 형상관리 시스템에 채우지 못한 내용 정리하기" }, { "title": "드디어 블로그 만들기 완성🏌️‍♀️", "url": "/posts/first-post/", "categories": "jekyll", "tags": "jekyll", "date": "2022-07-12 15:29:00 +0900", "snippet": "⛳️ 블로그 생성예전에 github 블로그를 만들었다가 복잡하고 원하는대로 되지 않아서 포기했었는데 오늘 갑자기 다시 만들고 싶어서 Jekyll를 이용해서 블로그를 만들었다.이번에도 처음부터 오류나고 안넘어가서 하지말까하다가 계속 쉬운 블로그 찾아다니며 어째저째 만들었다.왕초보를 위한 Github 블로그 만들기가 진짜 도움이 많이 되었고Jekyll 공식 가이드보면서 ruby 환경설정을 했다.몇 초는 무슨.. 나는 세시간 걸렸다.세시간 아님깃헙에 배포하는거까지 하루종일 걸렸음로컬에서는 잘나오는데 깃헙으로 배포할 때 계속 오류가 났다. Actions 탭에서 확인해보면 jekyll-theme-chirpy을 계속 못찾는다고 했다.소스를 zip으로 받아서 설치해서 설정을 했었는데 소스를 fork 받아서 다시 만들었다.왜 초기 세팅은 쉽게 되는 일이 없을까…오랜만에 머리 쥐어짰다. 맥북 아니었으면 주먹으로 화면 한 대 쳤을거다.⛳️ 블로그 초기 설정🪄 Skipping: _posts/2022-07-12-first post.md has a future date포맷에 맞춰서 글을 추가하고 브라우저에서 확인했는데 글이 안나왔다. 터미널에 이런 문구가 떴고찾아보니 한국 시간대에 맞춰서 작성해줘야 한다고 한다._config.yml에서 timezone: Asia/Seoul으로 설정했으니 그에 맞게 UTC+09:00로 설정해주어야 하는거 같다. 참고 jekyll 에서 drafts 혹은 post가 인식되지 않을 때. 📡 _config.yml에서 future:true로 설정하면 현재 시점 이후에 작성된 글도 보여준다.🪄 폰트 변경하기영문으로 볼 때는 예뻤는데 한글은 내 스타일이 아니라서 폰트를 변경했다./sass/addon/commons.scss와 /sass/addon/module.scss에 원하는 폰트를 import하고 설정하니 바로 적용되었다.지마켓에서 만든 Gmarket Sans를 적용해뒀는데 조만간 바꿀 거 같다.🪄 메인 화면블로그의 메인 화면이 pin: true을 설정한 글만 나타나게 설정되어있다. 이걸 바꿀지 말지.. 고민이다..고정시킬 글들이 많을까 싶고 무슨 기준으로 고정을 해두나 싶고 글이 없다면 메인 화면이 비어보이고.." } ]
